#+title: Aabm's literate configuration for GNU Emacs
#+author: aabm
#+email: aabm@disroot.org
#+startup: overview

* About

This is =Aabm's personal configuration for GNU Emacs.=

The goal of this configuration is to allow the use of Emacs as an
=Integrated Computing Environment=, or a =Virtual Lisp Machine=. This
means Emacs is treated as the primary tool for anything involving the
manipulation of text, and text interfaces are always preferred over
any alternatives.

This configuration covers many use cases. Among these are: writing,
programming, document preparation, reading mail and news feeds, and
much more.

This configuration is organized in a literate style, harnessing the
abilities of =org-mode=. The entire configuration is contained within
the =emacs.org= file, and all code is extracted (tangled) into the
files which are to be sourced by Emacs.

In line with the Emacs/GNU philosophy, this configuration is entirely
=free software=. See the [[*License][License]] section/file for more
details.

* License

Copyright © 2019-2021 Aabm <aabm@disroot.org>

Author: Aabm <aabm@disroot.org>
Keywords: literate programming, Emacs configuration
Homepage: https://gitlab.com/aabm/emacs

This file is NOT part of GNU Emacs.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Emacs; see the file LICENSE.  If not, you can visit
https://www.gnu.org/licenses/gpl-3.0.html or write to the Free
Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA.

* Startup settings
** early-init.el

Here we define all the options to be included in the =early-init.el=
file. This file is loaded very early in the startup process, making it
the main vessel for holding startup and performance tweaks.

*** Header

The license/package header for the =early-init.el= file.

#+begin_src emacs-lisp :tangle early-init.el
  ;;; early-init.el --- Emacs early configuration file
  ;; Copyright © 2019-2021 Aabm <aabm@disroot.org>

  ;; Author: Aabm <aabm@disroot.org>
  ;; Keywords: Emacs configuration, literate programming
  ;; Homepage: https://gitlab.com/aabm/emacs

  ;;; License:
  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or
  ;; modify it under the terms of the GNU General Public License as
  ;; published by the Free Software Foundation; either version 3, or (at
  ;; your option) any later version.

  ;; This program is distributed in the hope that it will be useful, but
  ;; WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  ;; General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs; see the file LICENSE.  If not, you can visit
  ;; https://www.gnu.org/licenses/gpl-3.0.html or write to the Free
  ;; Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  ;; MA 02110-1301, USA.

  ;;; Commentary:
  ;; Aabm's early-init settings for Emacs.
  ;; This file was automatically generated by `org-babel-tangle'. Do not
  ;; change this file. The real configuration is found in the `emacs.org'
  ;; file.
#+end_src

*** Startup options hack

A fairly simple hack to speed up startup in Emacs. It works by
disabling garbage gollection and the file name handler while Emacs is
starting, then enables them back up once the startup process is
complete.

#+begin_src emacs-lisp :tangle early-init.el
  (defvar startup-file-name-handler-alist file-name-handler-alist)

  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.6
        file-name-handler-alist nil)

  (defun startup-reset-defaults ()
    (setq gc-cons-threshold 16777216
          gc-cons-percentage 0.1
          file-name-handler-alist startup-file-name-handler-alist))

  (add-hook 'emacs-startup-hook #'startup-reset-defaults)
#+end_src

*** Disabling package.el

These are settings for disabling =package.el=, Emacs' built-in package
manager. Since Emacs 27, package.el is automatically started before
loading init.el, so it must be disabled in early-init.

#+begin_src emacs-lisp :tangle early-init.el
  (setq package-enable-at-startup nil
        package--init-file-ensured t)
#+end_src

*** Notify startup time

We enable a simple hook to print a message stating the length of
startup in the echo area.

#+begin_src emacs-lisp :tangle early-init.el
  (add-hook 'emacs-startup-hook
	    (lambda ()
	      (message "Emacs ready in %s with %d garbage collections."
	       (format "%.2f seconds"
		       (float-time
			(time-subtract after-init-time before-init-time))) gcs-done)))
#+end_src

** init.el

Here we define all the initialization options, to be included in the
=init.el= file.

*** Header
    
The license/package header for the =init.el= file.

#+begin_src emacs-lisp :tangle init.el
  ;;; init.el --- Main Emacs configuration file
  ;; Copyright © 2019-2021 Aabm <aabm@disroot.org>

  ;; Author: Aabm <aabm@disroot.org>
  ;; Keywords: literate programming, Emacs configuration
  ;; Homepage: https://gitlab.com/aabm/emacs

  ;;; License:
  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or
  ;; modify it under the terms of the GNU General Public License as
  ;; published by the Free Software Foundation; either version 3, or (at
  ;; your option) any later version.

  ;; This program is distributed in the hope that it will be useful, but
  ;; WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  ;; General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs; see the file LICENSE.  If not, you can visit
  ;; https://www.gnu.org/licenses/gpl-3.0.html or write to the Free
  ;; Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  ;; MA 02110-1301, USA.

  ;;; Commentary:
  ;; Aabm's init settings for Emacs.
  ;; This file was automatically generated by `org-babel-tangle'. Do not
  ;; change this file. The real configuration is found in the `emacs.org'
  ;; file.
#+end_src

*** Check version

This configuration, in its current state, is made for use with the
Emacs master branch. It does not aim to support previous versions of
Emacs. That said, this configuration /probably/ works with Emacs
version 27.1+. We check the version number in init, and trigger an
error if it is outdated.

#+begin_src emacs-lisp :tangle init.el
  (when (version< emacs-version "27.1")
    (error "This requires Emacs 27.1 and above! Preferably 28 (master), but 27 should be fine..."))
#+end_src

*** Bootstrap straight.el

 Here we bootstrap the =straight.el= package manager, which replaces
 package.el. This requires that =git= be installed on the system.

 #+begin_src emacs-lisp :tangle init.el
   (defvar bootstrap-version)
   (let ((bootstrap-file
          (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
         (bootstrap-version 5))
     (unless (file-exists-p bootstrap-file)
       (with-current-buffer
           (url-retrieve-synchronously
            "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
            'silent 'inhibit-cookies)
         (goto-char (point-max))
         (eval-print-last-sexp)))
     (load bootstrap-file nil 'nomessage))
 #+end_src
   
*** Installing and configuring use-package

In this section we install =use-package=, a collection of macros for
making package management easier and more convenient. It provides
great control over the process of loading a given package. It is used
for configuring packages and lazy loading those configurations. 

#+begin_src emacs-lisp :tangle init.el
  (straight-use-package 'use-package)

  (setq use-package-always-ensure nil)
  (setq use-package-always-defer t)
  (setq use-package-hook-name-suffix nil)
#+end_src

*** Installing other use-package related packages

#+begin_src emacs-lisp :tangle init.el
  (straight-use-package 'diminish)
#+end_src

*** Load path

Here we add the =elisp= directory and all its subdirectories to the
load path. This allows us to make and load custom packages.

#+begin_src emacs-lisp :tangle init.el
  (defun update-load-path (&rest _)
    "Update `load-path'."
    (dolist (dir '("elisp"))
      (push (expand-file-name dir user-emacs-directory) load-path)))

  (defun add-subdirs-to-load-path (&rest _)
    "Add subdirectories to `load-path'."
    (let ((default-directory (expand-file-name "elisp" user-emacs-directory)))
      (normal-top-level-add-subdirs-to-load-path)))

  (update-load-path)
  (add-subdirs-to-load-path)
#+end_src

*** Ensuring auto-compilation

Here we make sure that Emacs always has access to compiled elisp
instead of simple source files. The first setting here ensures that
outdated compiled files do not get loaded, and instead get recompiled
before being loaded.

#+begin_src emacs-lisp :tangle init.el
  (setq load-prefer-newer t)
#+end_src

* Quality of life changes
** Disabled commands

Here we make it so that no commands are disabled by Emacs. I want
access to all of them.

#+begin_src emacs-lisp :tangle init.el
  (setq disabled-command-function nil)
#+end_src

** Disable GUI elements

Emacs has by default a few GTK GUI elements which I find get in the
way. So we disable those.

#+begin_src emacs-lisp :tangle init.el
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

** Disable startup messages

This disables the default startup screen.

#+begin_src emacs-lisp :tangle init.el
  (setq inhibit-startup-screen t)
#+end_src

** Files
   
Emacs tends to litter all your directories with backups of all files
you visit. I find this behavior annoying and mostly useless. So we
disable it.

#+begin_src emacs-lisp :tangle init.el
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+end_src

Disable asking to open a large file.

#+begin_src emacs-lisp :tangle init.el
  (setq large-file-warning-threshold nil)
#+end_src

Automatically update files when they change on disk.

#+begin_src emacs-lisp :tangle init.el
  (auto-revert-mode t)
  (diminish 'auto-revert-mode)
#+end_src

** Change yes-or-no-p to y-or-n-p

Emacs has a lot of annoying prompts asking for user confirmation that
require you to type in "yes" everytime. This makes a simple "y"
sufficient.

#+begin_src emacs-lisp :tangle init.el
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Mouse and cursor settings

Default mouse behavior in Emacs is not ideal. I don't use the mouse
very often, but when I do, I like having it feel decent. We also
change some cursor options.

#+begin_src emacs-lisp :tangle init.el
  (blink-cursor-mode -1)

  (setq focus-follows-mouse t
	mouse-autoselect-window t)

  (setf mouse-wheel-scroll-amount '(3 ((shift) . 3))
	mouse-wheel-progressive-speed nil
	mouse-wheel-follow-mouse t
	scroll-step 1
	disabled-command-function nil)
#+end_src

* Text editing functionality
** Parens, brackets and quotes
*** Electric pairs

 Electric pairs make it so that every opening character that you type
 (parentheses, braces, brackets, quotation marks) is automatically
 matched with the corresponding closing character. This is handy at all
 times when editing, but especially useful for programming in Lisp.

 #+begin_src emacs-lisp :tangle init.el
   (setq electric-pair-pairs '((?\{ . ?\}) (?\( . ?\))
			       (?\[ . ?\]) (?\" . ?\")))
   (electric-pair-mode t)
 #+end_src

*** Highlight matching parentheses

 This minor mode highlights the parentheses that matches the one
 under/behind point. Useful for Lisp programming.

 #+begin_src emacs-lisp :tangle init.el
   (show-paren-mode t)
 #+end_src
 
** Text wrapping and filling
*** Visual lines

Emacs normally makes long lines extend off the edge of the screen. I
dislike this behavior and would rather have lines be (visually)
wrapped. Visual lines allow one to navigate lines just as they are
displayed, so a long line that gets wrapped will be treated as two
lines by most editing commands.

#+begin_src emacs-lisp :tangle init.el
  (global-visual-line-mode t)
  (diminish 'visual-line-mode)
#+end_src
   
*** Auto fill text

 When editing plain text files, I like my text to be automatically
 wrapped to a sane default. This avoids having to manually fill
 paragraphs.

 #+begin_src emacs-lisp :tangle init.el
   (add-hook 'text-mode-hook #'auto-fill-mode)
   (diminish 'auto-fill-function)
 #+end_src
 
** Navigation
*** Avy

#+begin_src emacs-lisp :tangle init.el
  (use-package avy
    :straight t
    :bind
    (("M-s" . avy-goto-char-2)))
#+end_src

** Sentences and words

A nice tweak to sentence navigation commands that makes them more
usable. We change the definition of a sentence to a more reasonable
"something that ends in a single space after punctuation".
   
#+begin_src emacs-lisp :tangle init.el
  (setq sentence-end-double-space nil)
#+end_src

** Region selection
*** Expand region

A neat little package that allows marking a region in increasing
bounds with each call. Useful for selecting things inside parentheses,
like in Lisp code, or quotes in prose.

#+begin_src emacs-lisp :tangle init.el
  (use-package expand-region
    :straight t
    :bind
    (("C-=" . er/expand-region)))
#+end_src

** Whitespace and indentation

#+begin_src emacs-lisp :tangle init.el
 (global-set-key (kbd "M-SPC") 'cycle-spacing) 

 (global-set-key (kbd "C-\\") 'indent-region)
#+end_src

** Clipboard and kill ring

Make Emacs read the system clipboard and integrate it with the
=kill-ring=.

#+begin_src emacs-lisp :tangle init.el
  (setq select-enable-clipboard t)
  (setq save-interprogram-paste-before-kill t)
#+end_src

* Readers
** Olivetti

 Olivetti mode is a minor mode that centers text on the screen. Useful
 for reading and focusing on writing.

 #+begin_src emacs-lisp :tangle init.el
   (use-package olivetti
     :straight t
     :custom
     (olivetti-body-width 100))
 #+end_src
 
** Reader mode

A custom minor mode using olivetti and other extensions for optimal
reading.

#+begin_src emacs-lisp :tangle init.el
  (defvar better-reading-mode-map (make-sparse-keymap))

  (define-minor-mode better-reading-mode
    "Minor Mode for better reading experience."
    :init-value nil
    :group aabm
    :keymap better-reading-mode-map
    (if better-reading-mode
	(progn
	  (and (fboundp 'olivetti-mode) (olivetti-mode 1))
	  (and (fboundp 'mixed-pitch-mode) (mixed-pitch-mode 1))
	  (text-scale-set +1))
      (progn
	(and (fboundp 'olivetti-mode) (olivetti-mode -1))
	(and (fboundp 'mixed-pitch-mode) (mixed-pitch-mode -1))
	(text-scale-set 0))))

  (global-set-key (kbd "C-c o") 'better-reading-mode)
  (define-key better-reading-mode-map (kbd "M-n") 'scroll-up-line)
  (define-key better-reading-mode-map (kbd "M-p") 'scroll-down-line)
#+end_src

** pdf-tools

PDF Tools is a fast and convenient PDF Reader. It appears here as a
replacement for docview, essentially.

#+begin_src emacs-lisp :tangle init.el
  (use-package pdf-tools
    :straight t
    :init
    (pdf-loader-install)
    :custom
    (pdf-view-resize-factor 1.1)
    (pdf-view-continuous nil)
    (pdf-view-display-size 'fit-page)
    :bind
    (:map pdf-view-mode-map
	  (("M-g g" . pdf-view-goto-page))))
#+end_src

** nov.el

A simple epub reader in Emacs.

#+begin_src emacs-lisp :tangle init.el
  (use-package nov
    :straight t
    :init
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
    :custom
    (nov-text-width 80)
    (nov-text-width t)
    (visual-fill-column-center-text t)  
    :hook
    ((nov-mode-hook . better-reading-mode))
    :bind
    (:map nov-mode-map
	  ((("M-n" . scroll-up-line)
	    ("M-p" . scroll-down-line)))))
#+end_src

* Minibuffer
** Which Key

=which-key= uses the minibuffer to display a nice buffer showing you
active keybindings in the currently typed prefix. It allows you to
navigate your keybindings via prefixes.

#+begin_src emacs-lisp :tangle init.el
  (use-package which-key
    :straight t
    :diminish which-key-mode
    :init
    (which-key-mode)
    :custom
    (which-key-idle-delay 0.4))
#+end_src

** Selectrum

=Selectrum= offers minibuffer completion and visual selection in the
vein of =ido=, but offering much more extensibility.

#+begin_src emacs-lisp :tangle init.el
  (straight-use-package 'orderless)

  (use-package selectrum
    :straight t
    :init
    (selectrum-mode)
    :custom
    (completion-styles '(basic substring partial-completion flex initials orderless))
    (completion-ignore-case t)
    (read-file-name-completion-ignore-case t)
    (read-buffer-completion-ignore-case t)
    (enable-recursive-minibuffers t)
    :bind
    (("C-x C-z" . selectrum-repeat)))

  (use-package selectrum-prescient
    :straight t
    :custom
    (selectrum-prescient-enable-filtering nil)
    :config
    (selectrum-prescient-mode)
    (prescient-persist-mode))

  (use-package consult
    :straight t
    :custom
    (consult-narrow-key "<")
    :bind
    (("M-y" . consult-yank)
     ("C-x b" . consult-buffer)
     ("M-g g" . consult-grep)
     ("M-g o" . consult-outline)
     ("M-g m" . consult-mark)
     ("M-g M-g" . consult-goto-line)))

  (use-package embark
    :straight t
    :bind
    (("C-," . embark-act))
    :custom
    (embark-action-indicator
     (lambda (map &optional _target)
       (which-key--show-keymap "Embark" map nil nil 'no-paging)
       #'which-key--hide-popup-ignore-command)
     embark-become-indicator embark-action-indicator))

  (use-package marginalia
    :straight t
    :bind
    ((:map minibuffer-local-map
	   ("M-a" . marginalia-cycle))))
#+end_src

** Miniedit

This package allows you to edit the contents of the minibuffer in a
dedicated buffer. This provides a better experience for dealing with
lots of content.

#+begin_src emacs-lisp :tangle init.el
  (use-package miniedit
    :straight t
    :init
    (miniedit-install))
#+end_src

* Programming modes
** General options
*** Line number display

 Here we make it so that line numbers are displayed in every
 programming mode buffer.

 #+begin_src emacs-lisp :tangle init.el
   (add-hook 'prog-mode-hook #'display-line-numbers-mode)
 #+end_src
 
*** Code completion

#+begin_src emacs-lisp :tangle init.el
  (use-package corfu
    :straight t
    :hook
    ((prog-mode-hook . corfu-mode)
     (eshell-mode-hook . corfu-mode))
    :bind
    (:map corfu-map
	  (("TAB" . corfu-next)
	   ("S-TAB" . corfu-previous)))
    :custom
    (corfu-cycle t))
#+end_src

** Emacs Lisp

Here we configure Emacs for editing Emacs.

#+begin_src emacs-lisp :tangle init.el
  (diminish 'eldoc-mode)
#+end_src

** Scheme

Here we include all the options for programming in the Scheme
language. We start with the Geiser package, which allows powerful
interactive Scheme sessions, and supports various implementations.

#+begin_src emacs-lisp :tangle init.el
  (use-package geiser
    :straight geiser-guile
    :init
    (setq geiser-active-implementations '(guile)))

  (use-package sicp
    :straight t)
#+end_src

** HTML and CSS

Webshit.

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'mhtml-mode-hook (lambda () (interactive) (auto-fill-mode -1)))
#+end_src

* Shell and Terminal emulation

Emacs comes with a few different solutions for shell and terminal
emulation built in. First and foremost, there is =M-x shell=, which is
a simple utility for running an external shell within Emacs, with the
advantage that it can be treated as a normal text buffer. =shell= can
also be used to power a REPL in other languages.

There is also =eshell= which on the surface is similar to shell, but
is, on the contrary, a much more powerful utility. =eshell= is a full
reimplementation of a /mostly/ POSIX-compliant shell, meaning it uses
its own version of programs like =ls=. This in turn means it is
system-agnostic, and can provide shell utilities even in system that
do not have them. Besides that, it can also read normal expressions in
=emacs lisp=, giving it a lot more flexibility. It is, as expected,
highly customizable, and we take advantage of that here, writing a lot
of custom functions to leverage eshell's power.

There are also /terminal/ emulation programs built into Emacs, namely
=term= and =ansi-term=, which are honestly not very good. As a
replacement, we install =vterm=, which fixes most of the flaws with
the built-in ones, while also allowing use of TUI programs.
  
** Eshell

#+begin_src emacs-lisp :tangle init.el
  (use-package eshell
    :init
    (defvar eshell-minor-mode-map (make-sparse-keymap))

    (define-minor-mode eshell-minor-mode
      "Minor mode that enables various custom keybindings for `eshell'."
      nil " esh" eshell-minor-mode-map)
    :hook
    ((eshell-mode-hook . eshell-minor-mode))
    :custom
    (eshell-cd-on-directory t)
    (eshell-banner-message "In the beginning was the command line.\n")
    :config
    (defun eshell-find-file-at-point ()
      "Finds file under point. Will open a dired buffer if file is a directory."
      (interactive)
      (let ((file (ffap-guess-file-name-at-point)))
	(if file
	    (find-file file)
	  (user-error "No file at point"))))

    (defun eshell-copy-file-path-at-point ()
      "Copies path to file at point to the kill ring"
      (interactive)
      (let ((file (ffap-guess-file-name-at-point)))
	(if file
	    (kill-new (concat (eshell/pwd) "/" file))
	  (user-error "No file at point"))))

    (defun eshell-cat-file-at-point ()
      "Outputs contents of file at point"
      (interactive)
      (let ((file (ffap-guess-file-name-at-point)))
	(if file
	    (progn
	      (goto-char (point-max))
	      (insert (concat "cat " file))
	      (eshell-send-input)))))

    (defun eshell-put-last-output-to-buffer ()
      "Produces a buffer with output of last `eshell' command."
      (interactive)
      (let ((eshell-output (kill-ring-save (eshell-beginning-of-output)
					   (eshell-end-of-output))))
	(with-current-buffer (get-buffer-create  "*last-eshell-output*")
	  (erase-buffer)
	  (yank)
	  (switch-to-buffer-other-window (current-buffer)))))

    (defun eshell-mkcd (dir)
      "Make a directory, or path, and switch to it."
      (interactive)
      (eshell/mkdir "-p" dir)
      (eshell/cd dir))

    (defun eshell-sudo-open (filename)
      "Open a file as root in Eshell, using TRAMP."
      (let ((qual-filename (if (string-match "^/" filename)
			       filename
			     (concat (expand-file-name (eshell/pwd)) "/" filename))))
	(switch-to-buffer
	 (find-file-noselect
	  (concat "/sudo::" qual-filename)))))

      (defalias 'mkcd 'eshell-mkcd)
      (defalias 'open 'find-file-other-window)
      (defalias 'sopen 'eshell-sudo-open)
      (defalias 'clean 'eshell/clear-scrollback)
      (defalias 'mkcd 'eshell-mkcd)
    :bind
    (("C-x s" . eshell)
     (:map eshell-minor-mode-map
	   (("C-c C-f" . eshell-find-file-at-point)
	    ("C-c C-w" . eshell-copy-file-path-at-point)
	    ("C-c C-o" . eshell-cat-file-at-point)
	    ("C-c C-b" . eshell-put-last-output-to-buffer)
	    ("C-c C-m" . mkdir)
	    ("C-c C-t" . chmod)))))
#+end_src

* Window and buffer management
** Windows
*** Switch and focus window

 Here we make some custom functions for splitting windows. We replace
 the defaults with these.

#+begin_src emacs-lisp :tangle init.el
   (defun split-window-below-and-follow ()
     "A simple replacement for `split-window-below', which automatically focuses the new window."
     (interactive)
     (split-window-below)
     (other-window 1))

   (defun split-window-right-and-follow ()
     "A simple replacement for `split-window-right', which automatically focuses the new window."
     (interactive)
     (split-window-right)
     (other-window 1))

   (global-set-key (kbd "C-x 2") 'split-window-below-and-follow)
   (global-set-key (kbd "C-x 3") 'split-window-right-and-follow)
#+end_src

*** Switch window

A simpler keybinding for switching windows.

#+begin_src emacs-lisp :tangle init.el
  (global-set-key (kbd "M-o") 'other-window)
#+end_src
    
** Buffers
*** Kill this buffer

 Here we make the =C-x k= key immediately kill the current buffer
 instead of prompting. We do this by making a custom function that is
 both simpler and more reliable than the built-in =kill-this-buffer=.

 #+begin_src emacs-lisp :tangle init.el
   (defun kill-this-buffer+ ()
     "Kill the current buffer. More reliable alternative to `kill-this-buffer'"
     (interactive)
     (kill-buffer))

   (global-set-key (kbd "C-x k") 'kill-this-buffer+)
 #+end_src

*** Ibuffer

#+begin_src emacs-lisp :tangle init.el
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

* Files and projects
** Dired

Some simple changes to dired behavior. We make it so that pressing =l=
moves up a directory without invoking another buffer.

#+begin_src emacs-lisp :tangle init.el
  (use-package dired
    :custom
    (dired-listing-switches "-alNF --group-directories-first")
    (dired-dwim-target t)
    (wdired-allow-to-change-permissions t)
    :config
    (defun dired-up-alternate-directory ()
      (interactive)
      (find-alternate-file ".."))

    (defun dired-xdg-open ()
      "Open the marked files using xdg-open."
      (interactive)
      (let ((file-list (dired-get-marked-files)))
	(mapc
	 (lambda (file-path)
	   (let ((process-connection-type nil))
	     (start-process "" nil "xdg-open" file-path)))
	 file-list)))
    :bind
    (:map dired-mode-map
	  (("l" . dired-up-alternate-directory)
	   ("RET" . dired-find-alternate-file)
	   ("M-RET" . dired-find-file)
	   ("v" . dired-xdg-open))))

  (use-package dired-hide-dotfiles
    :straight t
    :diminish dired-hide-dotfiles-mode
    :hook
    ((dired-mode-hook . dired-hide-dotfiles-mode))
    :bind
    (:map dired-mode-map
	  (("h" . dired-hide-dotfiles-mode))))

  (use-package dired-subtree
    :straight t
    :bind
    (:map dired-mode-map
	  (("TAB" . dired-subtree-toggle)
	   ("M-n" . dired-subtree-down)
	   ("M-p" . dired-subtree-up))))
#+end_src

** VC

The vc package is the built in version-control interaction library for
Emacs. The function =aabm-vc-git-log-grep= allows searching through
git logs.

#+begin_src emacs-lisp :tangle init.el
  (use-package vc
    :config
    (defvar aabm-vc-shell-output "*aabm-vc-output*")
    (defun aabm-vc-git-log-grep (pattern &optional diff)
      "Run ’git log --grep’ for PATTERN.
    With optional DIFF as a prefix (\\[universal-argument])
    argument, also show the corresponding diffs. 

  This function was taken from prot."
      (interactive
       (list (read-regexp "Search git log for PATTERN: ")
	     current-prefix-arg))
      (let* ((buf-name aabm-vc-shell-output)
	     (buf (get-buffer-create buf-name))
	     (diffs (if diff "-p" ""))
	     (type (if diff 'with-diff 'log-search))
	     (resize-mini-windows nil))
	(shell-command (format "git log %s --grep=%s -E --" diffs pattern) buf)
	(with-current-buffer buf
	  (setq-local vc-log-view-type type)
	  (setq-local revert-buffer-function nil)
	  (vc-git-region-history-mode))))
    :bind
    (:map vc-prefix-map
	  (("S" . aabm-vc-git-log-grep))))
#+end_src

** Magit

A powerful git porcelain. For those times when =vc= simply won't do.

#+begin_src emacs-lisp :tangle init.el
  (use-package magit
    :straight t
    :commands
    (magit-status magit)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    :bind
    (("C-x g" . magit-status)))
#+end_src

** Custom functions

Functions for general file management.

#+begin_src emacs-lisp :tangle init.el
  (defun delete-this-file ()
    (interactive)
    (delete-file (buffer-file-name)))

  (defun delete-this-file-and-buffer ()
    (interactive)
    (delete-file (buffer-file-name))
    (kill-buffer))
#+end_src

* Org mode
** Navigating headings

Some settings for better navigating org headings. First we make the
TAB key cycle all headings when pressed while point on the first line
of the buffer.

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :custom
    (org-cycle-global-at-bob t)
    (org-hide-leading-stars t)
    :bind
    (:map org-mode-map
	  (("M-n" . org-forward-element)
	   ("M-p" . org-backward-element)
	   ("C-M-n" . org-metadown)
	   ("C-M-p" . org-metaup)
	   ("C-M-f" . org-metaright)
	   ("C-M-b" . org-metaleft))))
#+end_src

** Source blocks

Here we define a few settings for the src blocks in org-mode. We force
indentation and syntax highlighting to work as if natively and have
org use the current window when opening dedicated edit buffers.
  
#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :custom
    (org-src-tab-acts-natively t)
    (org-src-fontify-natively t)
    (org-src-window-setup 'current-window)
    (org-structure-template-alist
     '(("a" . "export ascii")
       ("c" . "center")
       ("C" . "comment")
       ("ee" . "export")
       ("eh" . "export html")
       ("el" . "export latex")
       ("E" . "example")
       ("q" . "quote")
       ("ss" . "src")
       ("se" . "src emacs-lisp :tangle init.el\n")
       ("v" . "verse"))))
#+end_src

** Capture

Org capture is a powerful tool for creating notes and quickly
capturing information to be processed later. Here we define templates
for its usage.

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :bind
    (("C-c w" . org-capture))
    :custom
    (org-capture-bookmark nil))
    ;; (org-capture-templates))
#+end_src

** Export

#+begin_src emacs-lisp :tangle init.el
  (use-package ox-epub
    :straight t)

  (use-package org
    :init
    (setq org-export-backends '(ascii beamer epub html latex md))
    :custom
    (org-export-html-postamble nil))
#+end_src

** Roam

=org-roam= is a very powerful extension to org-mode. Essentially, it
is a package that maintains a relational database of links between
files, and allows navigation of this database using links and
backlinks. Org Roam is made as a tool for notetaking following the
=zettelkasten= method. It is quite a useful tool, and I personally
treat it as a second brain, in which I store all my information.

We also install =org-roam-server=, which runs a simple local web
server for displaying a visual representation of links between notes.

The final package installed is =deft=, a search tool for org
files. All these packages can be acessed under the C-c n map.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-roam
    :straight t
    :diminish org-roam-mode
    :config
    (org-roam-mode)
    :custom
    (org-roam-directory "~/org/roam/")
    (org-roam-index-file "~/org/roam/index.org")
    (org-roam-completion-system 'default)
    (org-roam-db-update-method 'immediate)
    (org-roam-graph-executable "/usr/bin/neato")
    (org-roam-graph-extra-config '(("overlap" . "false")))
    (org-roam-capture-templates
     '(("o" "Show: overview" plain (function org-roam--capture-get-point)
	"#+date:%T\n#+startup: overview\n#+roam_alias:\n"
	:file-name "%<%Y%m%d%H%M%S>-${slug}"
	:head "#+title: ${title}\n"
	:unnarrowed t)
       ("a" "Show: all" plain (function org-roam--capture-get-point)
	"#+date:%T\n#+startup: showall\n#+roam_alias:\n"
	:file-name "%<%Y%m%d%H%M%S>-${slug}"
	:head "#+title: ${title}\n"
	:unnarrowed t))) 
    :bind
    (("C-c n f" . org-roam-find-file)
     ("C-c n l" . org-roam-insert)
     ("C-c n L" . org-roam-insert-immediate)
     ("C-c n r" . org-roam-random-note)
     ("C-c n w" . org-roam-capture)))
#+end_src

* Web, news, mail, etc
** Elfeed

Elfeed is a complete RSS feed reader for Emacs. I use it as my main
program for reading and receiving news.

#+begin_src emacs-lisp :tangle init.el
  (use-package elfeed
    :straight t
    :config
    (load-file (expand-file-name "personal/feeds.el" user-emacs-directory))
    :hook
    ((elfeed-show-mode-hook . better-reading-mode))
    :bind
    (("C-c e" . elfeed)))
#+end_src

* Theming and customization
** Color theme

For now I'm just using one of the built-in themes.

#+begin_src emacs-lisp :tangle init.el
  (load-theme 'modus-vivendi t)
  (bind-key "<f7>" 'modus-themes-toggle)
#+end_src

** Faces
   
#+begin_src emacs-lisp :tangle init.el
  (custom-set-faces
   '(fixed-pitch ((t (:family "Iosevka 11")))))
#+end_src

** Font

Here we customize the font to be used by default by Emacs.

#+begin_src emacs-lisp :tangle init.el
  (add-to-list 'default-frame-alist '(font . "Iosevka medium extended 10"))
  (set-frame-font "Iosevka medium extended 10" nil t)
#+end_src

** Modeline

Here we make it so that the current position of point is displayed in
the modeline.

#+begin_src emacs-lisp :tangle init.el
  (line-number-mode t)
  (column-number-mode t)
#+end_src

