#+title: Aabm's literate configuration for GNU Emacs
#+author: aabm
#+email: aabm@disroot.org
#+startup: overview

* About this configuration

This is =Aabm's personal configuration for GNU Emacs=. In this
configuration, Emacs is treated as an =Integrated Computing
Enviroment= or a modern =Virtual Lisp Machine=. This means Emacs is
regarded as a general purpose tool for everything involving the
manipulation of text, and text interfaces are preferred whenever
possible. That is, writing, reading, mail, news, web browsing, and
much more. 

This configuration started as a simple toolset for academic studies
and document preparation, but has turned into so much more. Those
originally included tools are still present, though they have changed
quite a bit. 

This configuration is written in literate style, meaning documentation
is bundled along with the code, thanks to the power of =org-mode=. It
is structured as one long file named =emacs.org=, which has to be
extracted (tangled) into a few other files, mainly =early-init.el= and
=init.el=. Package management is handled entirely in a declarative,
functional manner, using =straight.el= and =use-package=.

In line with the Emacs philosophy, this configuration is =free
software=. See the [[*LICENSE][LICENSE]] section for more details.

* License

Copyright © 2019-2020 Aabm <aabm@disroot.org>

Author: Aabm <aabm@disroot.org>
URL: https://gitlab.com/aabm/emacs

This file is NOT part of GNU Emacs.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Emacs; see the file LICENSE.  If not, you can visit
https://www.gnu.org/licenses/gpl-3.0.html or write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.

** License headers for other files

#+begin_src emacs-lisp :tangle early-init.el
  ;; Copyright © 2019-2020 Aabm <aabm@disroot.org>

  ;; Author: Aabm <aabm@disroot.org>
  ;; URL: https://gitlab.com/aabm/emacs

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 3, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs; see the file LICENSE.  If not, you can visit
  ;; https://www.gnu.org/licenses/gpl-3.0.html or write to the
  ;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  ;; Boston, MA 02110-1301, USA.
#+end_src

#+begin_src emacs-lisp :tangle init.el
  ;; Copyright © 2019-2020 Aabm <aabm@disroot.org>

  ;; Author: Aabm <aabm@disroot.org>
  ;; URL: https://gitlab.com/aabm/emacs

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 3, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs; see the file LICENSE.  If not, you can visit
  ;; https://www.gnu.org/licenses/gpl-3.0.html or write to the
  ;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  ;; Boston, MA 02110-1301, USA.
#+end_src

* Early startup settings

This section contains settings for managing the process of
startup. They affect garbage collection, package management, and the
loading of the GUI. Most of these are done in order to achieve faster
startup times.

** Garbage collection

Here we disable the garbage collection during the startup
process. This is done by setting the GC threshold to an absurdly high
number, meaning GC never kicks in. Then, hooks are made so that
garbage collection is re-activated post-startup, in order to avoid
stability issues. Having no garbage collection speeds up startup
significantly, and does not usually incur in any issues.


#+begin_src emacs-lisp :tangle early-init.el
  (setq gc-cons-threshold 402653184
                  gc-cons-percentage 0.6)

  (defun startup/reset-gc ()
    (setq gc-cons-threshold 16777216
                  gc-cons-percentage 0.1))

  (add-hook 'emacs-startup-hook 'startup/revert-file-name-handler-alist)
  (add-hook 'emacs-startup-hook 'startup/reset-gc)
#+end_src

** File name handler

Here we disable the file name handler, for similar reasons and using
similar methods to the garbage collection settings above.

#+begin_src emacs-lisp :tangle early-init.el
  (defvar startup/file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)

  (defun startup/revert-file-name-handler-alist ()
    (setq file-name-handler-alist startup/file-name-handler-alist))
#+end_src

** GUI elements

These settings involve disabling GTK GUI elements like tool, menu and
scroll bars, since they are not really needed. Disabling them early at
startup avoids having them loaded.

#+begin_src emacs-lisp :tangle early-init.el
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)

  (set-window-scroll-bars (minibuffer-window) nil nil)
  (setq frame-inhibit-implied-resize t)
#+end_src

** Disabling package.el

These are settings for disabling =package.el=, Emacs' built-in package
manager. Since Emacs 27, package.el is automatically started before
loading init.el, so it must be disabled in early-init. As mentioned
before, this configuration uses =straight.el=, an external package
manager using a functional paradigm, somewhat similar to the Nix or
Guix package managers. There is nothing too wrong about package.el,
this choice was made simply because straight offers a few more
conveniences, and is generally faster, easier and more comfortable to
use than package.el.

#+begin_src emacs-lisp :tangle early-init.el
  (setq package-enable-at-startup nil ; no auto-init for package.el
        package--init-file-ensured t) ; no adding the annoying 'custom-set-variables' block to init.el
#+end_src

** Bootstrapping straight.el

Here we bootstrap the =straight.el= package manager, which replaces
package.el. This requires that =git= be installed on the system.

#+begin_src emacs-lisp :tangle init.el
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** Installing and configuring use-package

In this section we install =use-package=, a collection of macros for
making package management easier and more convenient. Note that
use-package is not a complete package manager unto itself, just a
wrapper around the existing package managers, that provides great
control over the process of loading a given package. It is also used
for configuring packages, and lazy loading those configurations.

#+begin_src emacs-lisp :tangle init.el
  (straight-use-package 'use-package)

  (setq use-package-always-ensure nil)
  (setq use-package-always-defer t)
  (setq use-package-hook-name-suffix nil))
#+end_src

** Ensuring auto-compilation of all elisp

Here we make sure that Emacs always has access to byte-compiled elisp
instead of simple source files. We ensure that outdated byte code
files do not get loaded.

#+begin_src emacs-lisp :tangle init.el
  (setq load-prefer-newer t)
#+end_src

* Quality of life changes

This section contains basic changes to Emacs behavior that can be
quite helpful. Configuration here does not involve the use of any
external packages.

** Enabling "advanced" keybindings

Emacs comes by default with some functions disabled from regular use;
calling one of these functions by its respective keybinding will yield
a message reminding the user that these are features recommended only
to advanced users, and that beginners should turn back. To be honest,
I never use any of these features very frequently, but I still don't
want to be confronted by a warning message in the rare case I do use
any of them. So here we enable these functions:

#+begin_src emacs-lisp :tangle init.el
  (put 'dired-find-alternate-file 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (setq disabled-command-function nil)
#+end_src

** Text formatting

Here we make sure all possible text encoding is done as UTF-8, which
is the universal standard. We also set code indentation for occasional
programming. 

#+begin_src emacs-lisp :tangle init.el
  (prefer-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8) 
  (set-keyboard-coding-system 'utf-8) 
  (set-selection-coding-system 'utf-8) 
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (setq locale-coding-system 'utf-8
        org-export-coding-system 'utf-8) 

  (setq-default tab-width 4) 
#+end_src

** Text display

The settings found here are a bit more varied, but they mostly center
around the way text and information is displayed on screen to the
user: line numbers, line highlighting, line wrapping, etc.

First, we make sure line numbers are displayed in every programming
major mode:

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src

Then we enable line and parentheses highlighting:

#+begin_src emacs-lisp :tangle init.el
  (when window-system (hl-line-mode t))
  (show-paren-mode 1)
#+end_src

Some settings for line truncation (namely disabling it) in favor of
visual lines:

#+begin_src emacs-lisp :tangle init.el
  (setq truncate-lines nil
        org-startup-truncated nil)
  (global-visual-line-mode t)
#+end_src

And finally, we enable pretty symbols. Pretty symbols convert lambdas
and other such elements to their respective symbols.

#+begin_src emacs-lisp :tangle init.el
  (when window-system (global-prettify-symbols-mode t))
#+end_src

** UI settings

These are basic setings related to the GUI. First we disable the
default startup screen, then we enable line and column number display
in the modeline.

#+begin_src emacs-lisp :tangle init.el
  (setq inhibit-startup-message t)

  (line-number-mode t)
  (column-number-mode t)
#+end_src

** Changing defaults

Here we disable or alter undesirable behaviors that Emacs has out of
the box. Most notable are the non-conservative scrolling, by which the
entire buffer will shift once the cursor wraps over the bottom, and
the lack of usage of the X clipboard.

Enabling conservative scrolling. Honestly cannot live without this:

#+begin_src emacs-lisp :tangle init.el
  (setq scroll-conservatively 100)
#+end_src

Disabling the bell ring altogether. I have seen some users setting the
bell ring to a visual queue, but I think that would be equally as
annoying as the sound.

#+begin_src emacs-lisp :tangle init.el
  (setq ring-bell-function 'ignore)
#+end_src

Here we enable integration with the system clipboard, and make it so
that all interactions with the X clipboard are also put into the kill-ring.

#+begin_src emacs-lisp :tangle init.el
  (setq select-enable-clipboard t
        save-interprogram-paste-before-kill t)
#+end_src

Here we disable the creation of backup and autosave files. I don't
like those cluttering up my directories.

#+begin_src emacs-lisp :tangle init.el
  (setq make-backup-files nil
        auto-save-default nil) 
#+end_src

Now for changing some prompts. First we change all "Yes or No" prompts
for simple "y or n", then we remove some prompts that appear when
killing buffers. 

#+begin_src emacs-lisp :tangle init.el
  (defalias 'yes-or-no-p 'y-or-n-p)
  (setq kill-buffer-query-functions nil)
#+end_src

Finally, we make sure Emacs automatically reloads any buffers when
they change on disk.

#+begin_src emacs-lisp :tangle init.el
  (global-auto-revert-mode t)
#+end_src

** Focus follows mouse

With these settings on, the window focus will follow the mouse
movement. This behavior is somewhat unorthodox for Emacs users, but I
find it very useful. You can still change windows using the keyboard
normally, as the focus will not get stuck under whichever window the
mouse points to.

#+begin_src emacs-lisp :tangle init.el
  (setq focus-follows-mouse t
        mouse-autoselect-window t)
#+end_src

** Fuzzy matching

In this section we add some =fuzzy completion= to all minibuffer
prompts. For now we use =Ido= for simplicity, but a later upgrade would
probably involve =Ivy= or =Selectrum=.

=ido-vertical= is a simple extension to the built in ido-mode that makes
the ido buffer show completions vertically, similar to Ivy and Helm.

We also install =smex=, which provides and ido menu for M-x.

#+begin_src 
  (use-package ido-vertical-mode
	:straight t
	:init
	(ido-mode)
	(ido-vertical-mode)
	:custom
	(ido-vertical-define-keys 'C-n-and-C-p-only))

  (use-package smex
	:straight t
	:bind
	("M-x" . smex))
#+end_src

* Base packages

In this section we install general purpose packages that are
frequently used later. These packages serve as building blocks for
configuration itself, or other packages.

** Diminish

#+begin_src emacs-lisp :tangle init.el
  (use-package diminish
    :straight t
    :after use-package
    :diminish eldoc-mode global-visual-line-mode visual-line-mode)
#+end_src

** General

=general.el= is a tool for simplifying the definition of custom
keybindings. It is frequently used over the length of this
configuration, so we install it here.

#+begin_src emacs-lisp :tangle init.el
  (straight-use-package 'general)
#+end_src

** Which Key

Which-key is a core package in many distributed configurations for
Emacs, and not without reason. It helps the user discover keybindings,
default or not, simply by displaying a list of active bindings as the
user types. Very useful for the times you can't remember long series
of bindings.

#+begin_src emacs-lisp
  (use-package which-key
    :straight t
    :config
    (which-key-mode)
    :custom
    (which-key-show-early-on-C-h t))
#+end_src

** Ivy, Swiper, Avy

=Ivy= is a lightweight but powerful =fuzzy completion= and =narrowing
search framework= for Emacs. It can be used to replace actions like
=find-file= or =switch-buffer=. Here it is paired with =Counsel=,
which adds further replacements for default actions. We replace the
default actions in this config, by simply overwriting default
keybindings with Counsel actions. =Ivy-rich= adds a few more bits of
information to Ivy menus, like a function description when using
counsel-M-x. 

=Swiper= is a search tool, for searching for text or regex
in-buffer. It pairs nicely with Ivy and Counsel. There is also =Avy=,
which is a buffer navigation tool using narrowing completion. Both of
these are later bound to keys.

#+begin_src emacs-lisp :tangle init.el
  (use-package ivy
    :straight ivy swiper counsel swiper avy ivy-rich
    :diminish ivy-mode counsel-mode
    :init
    (ivy-mode)
    (counsel-mode)
    (ivy-rich-mode)
    :custom
    (enable-recursive-minibuffers t))

  (general-define-key
     "C-s" 'swiper
     "C-r" 'swiper-backward
     "M-s" 'avy-goto-char-2
     "C-x C-f" 'counsel-find-file
     "C-x b" 'counsel-switch-buffer
     "C-x r b" 'counsel-bookmark
     "M-x" 'counsel-M-x
     "C-h f" 'counsel-describe-function
     "C-h v" 'counsel-describe-variable
     "C-h o" 'counsel-describe-symbol)
#+end_src

* Text editing

Under this section we put all configurations and packages that expand
Emacs' text editing capabilities. These mostly refer to editing motions
and styles defined by minor modes, not major modes.

** Electric pairs

Electric pairs are quite nice. This feature essentially adds matching
closing characters after point once you insert an opening
character. Especially good for Lisp programming, what with the
parentheses and all. Here we configure the characters to be affected
by electric-pair-mode.

#+begin_src emacs-lisp :tangle init.el
  (setq electric-pair-pairs '(
							 (?\{ . ?\})
							 (?\( . ?\))
							 (?\[ . ?\])
							 (?\" . ?\")
							 ))

  (electric-pair-mode t)
#+end_src

** Expand region

=expand-region= is a package for selecting a region based on sintactic
structures, that usually correlate to semantic value. In simple terms,
it marks a region and allows you to expand that region from small to
large, word to line to paragraph. In many ways, expand region can be
used similarly to Vim's delete/change inside/around commands. Expand
region is bound to the C-= keychord.

#+begin_src emacs-lisp :tangle init.el
  (use-package expand-region
    :straight t
    :bind
    ("C-=" . er/expand-region))
#+end_src

** Hungry delete

=hungry-delete= is a utility for making deletion of long bits of
whitespace easier.

#+begin_src emacs-lisp :tangle init.el
  (use-package hungry-delete
    :straight t
    :diminish
    :init
    (global-hungry-delete-mode))
#+end_src

** Multiple cursors

=multiple-cursors= is pretty self-explanatory. It allows the user to
control multiple cursors at the same time, one for each selected
line. This allows for some pretty convenient editing workflows. To use
multiple-cursors, simply mark the desired lines under a region, then
press C-c m, the keybinding defined here.

#+begin_src emacs-lisp :tangle init.el
  (use-package multiple-cursors
    :straight t
    :commands mc/edit-lines
    :bind
    ("C-c m" . mc/edit-lines))
#+end_src

** Writable grep

=wgrep= allows one to =grep= through a file or directory, edit the
output of grep, then write it into the files.

#+begin_src emacs-lisp :tangle init.el
(use-package wgrep
  :straight t
  :commands wgrep
  :custom
  (wgrep-auto-save-buffer t)
  (wgrep-change-readonly-file t)
  :bind (:map grep-mode-map
              ("C-x C-q" . wgrep-change-to-wgrep-mode)))
#+end_src

* Buffer, file and window management

In this section we deal with all packages relating to the fundamental
components of any Emacs workflow, those being buffers, files and
windows.

For =buffers=, we change keybindings and configure a few useful
utilities for managing them, such as =ibuffer=.

** Buffers

*** Generating scratch buffers

These are functions for easily generating =scratch buffers=, whether
they be in =org-mode= or in =lisp-interaction-mode=.

#+begin_src emacs-lisp :tangle init.el
  (defun aabm/generate-org-buffer ()
    "Create and switch to a temporary org mode buffer with a random name."
    (interactive)
    (switch-to-buffer (make-temp-name "org-"))
    (org-mode))

  (defun aabm/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-"))
    (lisp-interaction-mode))
#+end_src

*** Keybindings

#+begin_src emacs-lisp :tangle init.el
  (general-define-key
   "C-x k" 'kill-this-buffer
   "C-x C-b" 'ibuffer
   "C-c b o" 'aabm/generate-org-buffer
   "C-c b s" 'aabm/generate-scratch-buffer)
#+end_src

** Dired

=dired=, or the =directory editor= is Emacs' built in file manager.

#+begin_src emacs-lisp :tangle init.el
  (use-package dired
    :straight peep-dired dired-subtree dired-hide-dotfiles
    :commands dired
  
    :custom
    (dired-dwim-target t)
    (dired-listing-switches "-alhNF --group-directories-first")
    (peep-dired-cleanup-on-disable t)
    (peep-dired-ignored-extensions '("mkv" "iso" "mp4"))

    :config
  
    (defun aabm/dired-xdg-open ()
      "Open the marked files using xdg-open"
      (interactive)
      (let ((file-list (dired-get-marked-files)))
        (mapc
         (lambda (file-path)
           (let ((process-connection-type nil))
             (start-process "" nil "xdg-open" file-path)))
         file-list)))

    (dired-hide-dotfiles-mode t)
  
    :bind
    (:map dired-mode-map
          ("RET" . dired-find-alternate-file)
          ("M-RET" . dired-find-file)
          ("DEL" . dired-up-directory)
          ("TAB" . dired-subtree-insert)
          ("C-c d m" . mkdir)
          ("C-c d c" . chmod)
          ("h" . dired-hide-dotfiles-mode)
          ("i" . 'peep-dired)
          ("I" . 'image-dired)
          ("v" . aabm/dired-xdg-open)))
#+end_src

** Magit

=Magit= is a complete =git= frontend for Emacs. It makes usage of git
significantly easier and more intuitive. No more typing esoteric shell
commands you barely understand.

#+begin_src emacs-lisp :tangle init.el
  (use-package magit
    :straight t
    :commands magit-status
    :bind
    ("C-x g" . magit-status))
#+end_src

* Writing, notetaking and reading

Under this section are all the configuration and packages relating to
=reading= (books, papers, documents) and =writing= (notetaking, document
production, word processing). As one might expect, this section is
mainly centered around =org-mode=, as well as any packages that
contribute org workflows.

** Olivetti and Writeroom

Before we get to any further customization on the reading/writing
workflow, we install a few packages that make that experience a bit
more focused. First is =olivetti-mode=, which is a simple mode for
centering text in the buffer. It will later be used along with some
major modes, in order to improve their readability. 

The second package is =writeroom-mode=, which is, in some ways, an
expanded version of olivetti (though they share no code). Writeroom,
when called, not only centers text in the current buffer, but also
kills all other windows, fullscreens the current frame, and eliminates
all transparency. This is done to provide a focused experience for
reading and writing.

#+begin_src emacs-lisp :tangle init.el
  (straight-use-package 'olivetti)
  (straight-use-package 'writeroom-mode)
#+end_src

** Org

Now for =org-mode=. Org is one of the central packages in this
configuration, so we will do a lot of customization to it.

*** Essential configuration

First, we ensure the latest version of org is installed, then change
some basic options. These are:
- Setting the default directory for org files
- Changing the ellipsis for better looking headings
- Hiding leading stars in headings
- Adding nice visual indentation to all org buffers
- Better keybindings for heading navigation

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :straight t
    :custom
    (org-directory "~/org/")
    (org-ellipsis "⬎")
    (org-hide-leading-stars t)
    (org-html-postamble nil)  
    :hook
    (org-mode-hook . org-indent-mode)
    :diminish org-indent-mode
    :bind
    (:map org-mode-map
          ("M-n" . org-forward-element)
          ("M-p" . org-backward-element)))
#+end_src

*** Agenda, Tasks and TODOs

This section revolves entirely around the =org-agenda=, along with all
handling of tasks and TODOs.

First, we:
- Set default agenda directory
- Setting the archive file, where all completed tasks will be stored
- Ensure tasks cannot be completed if they have unfinished dependencies
- Add a timestamp to all completed tasks

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :custom
    (org-agenda-files "~/org/agenda.org")
    (org-archive-location (concat org-directory "/archive.org::"))
    (org-enforce-todo-dependencies t)
    (org-enforce-todo-checkbox-dependencies t)
    (org-log-done 'time))
#+end_src

Finally, we define a function that automatically marks the current
task as DONE, then sends it to the archive.

#+begin_src emacs-lisp :tangle init.el
  (defun aabm/org-todo-done-and-archive ()
    "Sets current org task do DONE and sends it to org-archive-location."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))
#+end_src

*** Capture

Here we define the file where captured notes will be stored by
default, as well as the templates to use for capture.

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :custom
    (org-default-notes-file (concat org-directory "agenda.org"))
    (org-capture-templates
     '(("a" "Assignments"
        entry
        (file+headline "agenda.org" "Assignments")
        "* TODO %^{prompt|Política|Antropologia|Sociologia|Economia|Filosofia} - %A\n%?\nDEADLINE: %^T"))))
#+end_src

*** Structure blocks

These are the settings regarding org's structure blocks (src, quote,
etc) and the templates for quickly creating them. First we enable
proper indentation and syntax highlighting in source blocks, then make
it so that editing src blocks in their own buffer does not create a
new window, rather take up the current one. Finally, we define
structure templates for creating blocks.

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :custom
    (org-src-tab-acts-natively t)
    (org-src-fontify-natively t)
    (org-src-window-setup 'current-window)
    (org-structure-template-alist
          '(("c" . "center\n")
            ("e" . "src emacs-lisp :tangle init.el\n")
            ("h" . "export html\n")
            ("l" . "export latex\n")
            ("q" . "quote\n")
            ("s" . "src")
            ("tn" . "src conf :tangle ~/.config/")
            ("tx" . "src haskell :tangle ~/.xmonad/xmonad.hs\n")
            ("tz" . "src shell :tangle ~/.config/zsh/.zshrc\n")
            ("tp" . "src conf :tangle ~/.config/polybar/config\n")
            ("tb" . "src shell :tangle ~/.config/bspwm/bspwmrc\n")
            ("ts" . "src fundamental :tangle ~/.config/sxhkd/sxhkdrc\n")
            ("tq" . "src python :tangle ~/.config/qutebrowser/config.py\n")
            ("v" . "verse\n"))))
#+end_src

*** Org Roam

=org-roam= is a very powerful extension to org-mode. Essentially, it
is a package that maintains a relational database of links between
files, and allows navigation of this database using links and
backlinks. Org Roam is made as a tool for notetaking following the
=zettelkasten= method. It is quite a useful tool, and I personally
treat it as a second brain, in which I store all my information.

We also install =org-roam-server=, which runs a simple local web
server for displaying a visual representation of links between notes.

The final package installed is =deft=, a search tool for org
files. All these packages can be acessed under the C-c n map.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-roam
    :straight t
    :diminish
    :config
    (org-roam-mode)
    :custom
    (org-roam-directory "~/org/roam/")
    (org-roam-index-file "~/org/roam/index.org")
    (org-roam-encrypt-files nil)
    (org-roam-completion-system 'ivy)
    (org-roam-graph-executable "/usr/bin/neato")
    (org-roam-graph-extra-config '(("overlap" . "false")))
    (org-roam-capture-templates
     '(("t" "tagged" plain (function org-roam--capture-get-point)
        "#+date:%T\n#+startup: overview\n#+roam_tags: %?\n#+roam_alias:"
        :file-name "%<%Y%m%d%H%M%S>-${slug}"
        :head "#+title: ${title}\n"
        :unnarrowed t))))

  (use-package org-roam-server
    :straight t
    :custom
    (org-roam-server-host "127.0.0.1")
    (org-roam-server-port 8080)
    (org-roam-server-authenticate nil)
    (org-roam-server-export-inline-images t)
    (org-roam-server-serve-files nil)
    (org-roam-server-served-file-extensions '("pdf" "mp4" "ogv"))
    (org-roam-server-network-poll t)
    (org-roam-server-network-arrows nil)
    (org-roam-server-network-label-truncate t)
    (org-roam-server-network-label-truncate-length 60)
    (org-roam-server-network-label-wrap-length 20))

  (use-package deft
    :straight t
    :custom
    (deft-recursive t)
    (deft-use-filter-string-for-filename t)
    (deft-default-extension "org")
    (deft-directory "~/docs/roam/"))

  (general-define-key
   "C-c n z" 'org-roam
   "C-c n f" 'org-roam-find-file
   "C-c n l" 'org-roam-insert
   "C-c n c" 'org-roam-random-note
   "C-c n g" 'org-roam-server-mode
   "C-c n d" 'org-roam-dailies-date
   "C-c n s" 'deft)
#+end_src

*** Org Superstar

=org-superstar= is a package that replaces the asterisks in org
headings with nice looking Unicode characters.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-superstar
    :straight t
    :hook
    (org-mode-hook . org-superstar-mode))
#+end_src

** Reading PDFs and EPUBs

Emacs can serve as a great tool for reading books. In this section we
configure it as a PDF reader, with the help of the =pdf-tools=
package, and as an EPUB reader, with the =nov.el= package.

*** PDF Tools

**** Use-package

The configurations for pdf-tools here simply involve the zooming, page
fit and continuity of pages. We also ensure that pdf-tools is able to
install and configure its external binary on first startup.

#+begin_src emacs-lisp :tangle init.el
  (use-package pdf-tools
    :straight t
    :defer nil
    :config
    (pdf-loader-install)
    :custom
    (pdf-view-resize-factor 1.1)
    (pdf-view-continuous nil)
    (pdf-view-display-size 'fit-page))
#+end_src

**** Custom functions

Now's the time for some custom function definitions. The first
function, =aabm/pdf-view-continuous-toggle= is made for toggling the
page continuity. With that off, scrolling over a page will not take
you to the next page, you must do that explicitly.

#+begin_src emacs-lisp :tangle init.el
(defun aabm/pdf-view-continuous-toggle ()
  (interactive)
  (cond ((not pdf-view-continuous)
         (setq pdf-view-continuous t)
         (message "Page scrolling: Continous"))
        (t
         (setq pdf-view-continuous nil)
         (message "Page scrolling: Constrained"))))
#+end_src

The second function, =aabm/pdf-view-open-in-zathura= allows opening
the current pdf in the external viewer called =zathura=. This function
can easily be changed to use any other viewer, like =evince= or
=okular=.

#+begin_src emacs-lisp :tangle init.el
(defun aabm/pdf-view-open-in-zathura ()
  "Open the current PDF with ‘zathura’."
  (interactive)
  (save-window-excursion
    (let ((current-file (buffer-file-name))
          (current-page (number-to-string (pdf-view-current-page))))
      (async-shell-command
       (format "zathura -P %s \"%s\"" current-page current-file))))
  (message "Sent to Zathura"))
#+end_src

Finally, the third function, =aabm/pdf-view-show-current-page=, exists
for printing the current page number to the echo area.

#+begin_src emacs-lisp :tangle init.el
(defun aabm/pdf-view-show-current-page ()
  "Show the current page."
  (interactive)
  (message "Page: %s" (pdf-view-current-page)))
#+end_src

**** Keybindings

Now we bind these functions and others to keys in the =pdf-view-mode-map=.

#+begin_src emacs-lisp :tangle init.el
  (general-define-key
   :keymaps 'pdf-view-mode-map
   "C-s" 'isearch-forward
   "C-r" 'isearch-backward
   "C-c d" 'pdf-view-midnight-minor-mode
   "C-c z" 'aabm/pdf-view-open-in-zathura
   "C-c p" 'aabm/pdf-view-show-current-page
   "C-c t" 'aabm/pdf-view-continuous-toggle 
   "C-a" 'image-scroll-right
   "C-e" 'image-scroll-left
   "f" 'pdf-view-goto-page)
#+end_src

*** nov.el

Now we install =nov.el=, which is a small package for reading .epub
files with Emacs. The only significant configuration done here is
hooking nov.el to olivetti-mode.

#+begin_src emacs-lisp :tangle init.el
  (use-package nov
    :straight t
    :init
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
    :custom
    (olivetti-body-width 104)
    :hook
    (nov-mode . olivetti-mode)
    :bind
    (:map nov-mode-map
            ("M-n" . scroll-up-line)
            ("M-p" . scroll-down-line)))
#+end_src

* Programming

Here are all the configurations oriented exclusively around
=programming=. These are mainly just simple =use-package= declarations
for programming major modes, which is really all I need.

** Lisp

=Lisp is the most powerful programming language=. Under this section
are configurations for all =Lisp= programming, whether =Emacs Lisp=,
=Common Lisp= or some variant of =Scheme=. I normally don't use
anything besides Elisp on a regular basis, but you never know. Also
included here are the configurations that help in the process of
configuring Emacs. 

*** Rebuilding Emacs configuration

This is a function for easily =rebuilding my Emacs config=. It
tangles all code blocks then byte-compiles the necessary files. Note
that it does not load these files.

#+begin_src emacs-lisp :tangle init.el
  (defun aabm/build-emacs ()
    "This function is used for completely rebuilding the Emacs
  configuration file after changes are made to it. First, the buffer
  visiting that file is saved, then all code blocks are tangled from
  the file, and finally all resulting files are byte-compiled."
    (interactive)
    (let ((prog-mode-hook nil))
      (save-buffer "emacs.org")
      (org-babel-tangle-file (concat user-emacs-directory "emacs.org"))
      (delete-file (concat user-emacs-directory "early-init.elc"))
      ;; (byte-compile-file (concat user-emacs-directory "early-init.el"))
      (delete-file (concat user-emacs-directory "init.elc"))	
      ;; (byte-compile-file (concat user-emacs-directory "init.el"))
      (message "Emacs configuration succesfully rebuilt!")))

  (general-define-key
   "H-c e" 'aabm/build-emacs)
#+end_src
 
*** Loading files conditionally

This is a simple function for loading files conditionally (that is,
only if they exist). Simply put, it makes the process of loading
external files (such as those containing personal information not
included in this config) a lot easier.

#+begin_src emacs-lisp :tangle init.el
(defun aabm/load-file-if (file)
  "Check if FILE exists, and if so, load it."
  (if (file-exists-p file)
    (load-file file)))
#+end_src

** Haskell

I started using =Haskell= due to =Xmonad=. Don't use it for anything
other than that.

#+begin_src emacs-lisp :tangle init.el
  (use-package haskell-mode
    :straight t)
#+end_src

* Shell and terminal emulation

** Eshell

#+begin_src emacs-lisp :tangle init.el
  (use-package eshell
    :bind
    ("C-x s" . eshell)
    :config
    (defalias 'open 'find-file-other-window)
    (defalias 'clean 'eshell/clear-scrollback)
    (defalias 'mkcd 'aabm/eshell-mkcd)
    (defalias 'su-open 'aabm/eshell-sudo-open)

    (defun aabm/eshell-sudo-open (filename)
      "Open a file as root in Eshell."
      (let ((qual-filename (if (string-match "^/" filename)
                               filename
                             (concat (expand-file-name (eshell/pwd)) "/" filename))))
        (switch-to-buffer
         (find-file-noselect
          (concat "/sudo::" qual-filename)))))

    (defun aabm/eshell-kill-save-file-at-point ()
      "Copies path to file at point to the kill ring"
      (interactive)
      (let ((file (ffap-file-at-point)))
        (if file
            (kill-new (concat (eshell/pwd) "/" file))
          (user-error "No file at point"))))

    (defun aabm/eshell-find-file-at-point ()
      "Finds file under point. Will open a dired buffer if file is a directory."
      (interactive)
      (let ((file (ffap-file-at-point)))
        (if file
            (find-file file)
          (user-error "No file at point"))))

    (defun aabm/eshell-cat-file-at-point ()
      "Outputs contents of file at point"
      (interactive)
      (let ((file (ffap-file-at-point)))
        (if file
            (progn
              (goto-char (point-max))
              (insert (concat "cat " file))
              (eshell-send-input)))))

    (defun aabm/eshell-mkcd (dir)
      "Make a directory, or path, and switch to it."
      (interactive)
      (eshell/mkdir "-p" dir)
      (eshell/cd dir))

    (defun aabm/eshell-put-last-output-to-buffer ()
      "Produces a buffer with output of last `eshell' command."
      (interactive)
      (let ((eshell-output (kill-ring-save (eshell-beginning-of-output)
                                           (eshell-end-of-output))))
        (with-current-buffer (get-buffer-create  "*last-eshell-output*")
          (erase-buffer)
          (yank)
          (switch-to-buffer-other-window (current-buffer)))))
    :custom
    (eshell-prompt-regexp "^[^αλ\n]*[αλ] ")
    (eshell-prompt-function
     (lambda nil
       (concat
        (if (string= (eshell/pwd) (getenv "HOME"))
            (propertize "~" 'face `(:foreground "#458588"))
          (replace-regexp-in-string
           (getenv "HOME")
           (propertize "~" 'face `(:foreground "#458588"))
           (propertize (eshell/pwd) 'face `(:foreground "#458588"))))
        (if (= (user-uid) 0)
            (propertize " α " 'face `(:foreground "#CC241D"))
          (propertize " λ " 'face `(:foreground "#98971A"))))))

    (eshell-banner-message "")
    (eshell-highlight-prompt nil)


    )
#+end_src

** Vterm

#+begin_src emacs-lisp :tangle init.el
  (use-package vterm
    :straight t
    :bind
    ("C-x v" . vterm))
#+end_src

* News, email and web browsing

This section includes all customization necessary for using Emacs as a
mail client with =mu4e=, mailing list reader with =Gnus=, RSS news
reader =Elfeed= and text-based web browser, with =eww=.

** User credentials

This section loads my personal credentials file. The contents of the
file are minimal, but are kept separate from this file so that
distribution of this configuration does not contain any personal
information that I'd rather not leak to the public.

#+begin_src emacs-lisp :tangle init.el
  (aabm/load-file-if (concat user-emacs-directory "creds.el.gpg"))
#+end_src

If you wish to use the above setting, simply create a file in your
user-emacs-directory with the name "creds.el" containing something
like the example below:

#+begin_src emacs-lisp 
  ;;; Example setting for a credentials file:
  ;; (setq user-full-name "Your Name Here"
  ;;       user-mail-address "your@email.here"
  ;;       calendar-latitude 00.00
  ;;       calendar-longitude 000.00
  ;;       calendar-location-name "City, State")
#+end_src

** Elfeed

=Elfeed= is a complete RSS/Atom feed reader for Emacs. The
configurations applied here are not so complex. First, we have elfeed
load an external file containing all feeds. Then, there is a function
definition for opening video feed links (youtube, invidious) in an
external video player, namely =mpv=, which is bound to the v key.

#+begin_src emacs-lisp :tangle init.el
  (use-package elfeed
    :straight t
    :config
    (aabm/load-file-if (concat user-emacs-directory "feeds.el.gpg"))
    :bind
    ("C-c e" . elfeed)
    (:map elfeed-show-mode-map
          ("M-n" . scroll-up-line)
          ("M-p" . scroll-down-line))
    :hook
    (elfeed-show-mode . olivetti-mode))

  (defun aabm/elfeed-play-with-mpv ()
    "Play entry link with mpv."
    (interactive)
    (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
          (quality-arg "")
          (quality-val (completing-read "Max height resolution (0 for unlimited): " '("0" "480" "720") nil nil)))
      (setq quality-val (string-to-number quality-val))
      (message "Opening %s with height≤%s with mpv..." (elfeed-entry-link entry) quality-val)
      (when (< 0 quality-val)
        (setq quality-arg (format "--ytdl-format=[height<=?%s]" quality-val)))
      (start-process "elfeed-mpv" nil "mpv" quality-arg (elfeed-entry-link entry))))

  (general-define-key
   :keymaps '(elfeed-search-mode-map elfeed-show-mode-map)
   "v" 'aabm/elfeed-play-with-mpv)
#+end_src

** mu4e

=mu4e= is a full featured mail client for Emacs. It requires use of
external tools, namely:
- A tool for pulling mail from the server, like =isync=
- A tool fore sending mail over SMTP, like =msmtp=
- =mu=, which is mu4e's own mail indexing and search tool

The settings contained in this block basically set mu4e up for usage
of those tools.

#+begin_src emacs-lisp :tangle init.el
  (use-package mu4e
    :straight t
    :commands mu4e mu4e-compose-new
    :custom
    (mu4e-maildir "~/.mail/disroot/")
    (mu4e-get-mail-command "/usr/bin/mbsync -a")
    (mu4e-html2text-command "/usr/bin/w3m -T text/html")
    (mu4e-drafts-folder "/drafts")
    (mu4e-sent-folder "/sent")
    (mu4e-trash-folder "/trash")
    (message-send-mail-function 'message-send-mail-with-sendmail)
    (sendmail-program "/usr/bin/msmtp")
    (message-sendmail-extra-arguments '("--read-envelope-from"))
    (message-sendmail-f-is-evil 't)
    (mu4e-completing-read-function 'ivy-completing-read)
    (mu4e-confirm-quit nil)
    (mu4e-compose-signature
     '(user-full-name))
    :bind
    ("H-x m" . mu4e)
    ("C-x m" . mu4e-compose-new))
#+end_src

** eww

=eww=, the Emacs Web Wowser, is a simple text-based web browser built
into Emacs. I use it somewhat frequently. So far the only
customization done here is making sure eww is uses olivetti-mode, for
better readability in web pages.

#+begin_src emacs-lisp :tangle init.el
  (use-package eww
    :hook
    (eww-mode . olivetti-mode)
    :bind
    (:map eww-mode-map
          ("M-n" . scroll-up-line)
          ("M-p" . scroll-down-line)))
#+end_src

* Media management

Emacs can be used to manage all sorts of media playback
utilities. This is usually accomplished by means of packages that
provide frontends for certain local applications. For instance, we use
=mingus= to interface with =mpd= for music playback.

** Music

#+begin_src emacs-lisp :tangle init.el
  (use-package mingus
    :straight t
    :commands mingus
    :bind
    ("H-m" . mingus)
    :config
    (general-define-key
     :keymaps '(mingus-browse-map mingus-playlist-map)
     "q" 'kill-this-buffer))
#+end_src

** Videos

These are tools for downloading and streaming videos from the web.

*** ytdl

=ytdl= is a utility for downloading videos from YouTube using
=youtube-dl=. Here we configure the standard directories to be used by
it.

#+begin_src emacs-lisp :tangle init.el
  (use-package ytdl
    :straight t
    :custom
    (ytdl-download-folder "~/vids")
    (ytdl-video-folder "~/vids")
    (ytdl-download-types '(("academic" "a" "~/vid/academic" nil)
                           ("documentaries" "d" "~/vid/documentaries" nil)
                           ("memes" "m" "~/vid/memes" nil)
                           ("lewd" "l" "~/vid/lewd" nil)
                           ("other" "o" "~/vid/" nil)))
    :bind
    ("C-c d" . ytdl-download))
#+end_src

*** ytel

=ytel= is a package for searching for YouTube videos using the
=Invidious= API. It displays search results in a buffer similar to
elfeed.

#+begin_src emacs-lisp :tangle init.el
  (use-package ytel
    :straight t
    :custom
    (ytel-invidious-api-url "https://invidious.snopyta.org")  
    :config
    (defun ytel-watch-mpv ()
      "Stream video at point in mpv."
      (interactive)
      (let* ((video (ytel-get-current-video))
             (id    (ytel-video-id video)))
        (start-process "ytel mpv" nil
                       "mpv"
                       (concat "https://www.youtube.com/watch?v=" id))
        "--ytdl-format=bestvideo[height<=?720]+bestaudio/best")
      (message "Starting stream..."))
    :bind
    ("C-c y" . ytel)
    (:map ytel-mode-map
          ("RET" . ytel-watch-mpv)))
#+end_src

* Theming and appearance

Finally, ricing. In this section we install color themes and customize
them, customize face attributes, and set frame options.

** Color theme

Here we install a bunch of themes I like. These involve:
- Modus Themes by Protesilaos Stavrou
- The Majapahit theme
- The entire collection of themes from Doom Emacs, just for Gruvbox

The customizations applied to the doom-themes simply ensure some basic
features are enabled. We also ensure the Doom Gruvbox theme always

uses the Hard contrast variant, with a #1D2021 background instead of
the normal #282828.

#+begin_src emacs-lisp :tangle init.el
  (straight-use-package 'modus-operandi-theme)
  (straight-use-package 'modus-vivendi-theme)

  (use-package doom-themes
    :straight t
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    (doom-gruvbox-dark-variant "hard")
    (doom-themes-org-config))

  (load-theme 'doom-gruvbox t)
  ;; (load-theme 'modus-operandi t t)
  ;; (run-at-time "05:00" (* 60 60 24)
  ;;              (lambda ()
  ;;                (enable-theme 'modus-operandi)))

  ;; (load-theme 'modus-vivendi t t)
  ;; (run-at-time "21:00" (* 60 60 24)
  ;;              (lambda ()
  ;;                (enable-theme 'modus-vivendi)))
#+end_src

** Face customization

This is the face customization section. Here we change any faces that
do not look good by default. So far, the only faces included here
relate to fonts.

#+begin_src emacs-lisp :tangle init.el
  (set-face-attribute 'fixed-pitch-serif t
                      :inherit 'default)

  (set-face-attribute 'variable-pitch t
                      :height 150
                      :family "Cantarell")
#+end_src

** Frame options

Now we set the options to be used by default by the Emacs frame. These
include fonts, frame name (to be used by the window manager's
titlebar), frame size and transparency.

   #+begin_src emacs-lisp :tangle init.el
     (set-frame-font "Iosevka 12" nil t)
     (setq frame-title-format "%b")

     (add-to-list 'default-frame-alist '(font . "Iosevka 12"))

     (set-frame-parameter (selected-frame) 'alpha '(97 95))
     (add-to-list 'default-frame-alist '(alpha 97 95))
   #+end_src






