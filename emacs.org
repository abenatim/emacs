
#+title: Aabm's literate configuration for GNU Emacs
#+author: aabm
#+email: aabm@disroot.org
#+seq_todo: TODO(t) | LEGACY(l) DONE(d)
#+startup: overview

* About this configuration

This is =Aabm's personal configuration for GNU Emacs=. In this
configuration, Emacs is treated as an =Integrated Computing
Enviroment= or a modern =Virtual Lisp Machine=. This means Emacs is
regarded as a general purpose tool for everything involving the
manipulation of text, and text interfaces are preferred whenever
possible. That is, writing, reading, mail, news, web browsing, and
much more. 

This configuration started as a simple toolset for academic studies
and document preparation, but has turned into so much more. Those
originally included tools are still present, though they have changed
quite a bit. 

This configuration is written in literate style, meaning documentation
is bundled along with the code, thanks to the power of =org-mode=. It
is structured as one long file named =emacs.org=, which has to be
extracted (tangled) into a few other files, mainly =early-init.el= and
=init.el=. Package management is handled entirely in a declarative,
functional manner, using =straight.el= and =use-package=.

In line with the Emacs philosophy, this configuration is =free
software=. See the [[*License][License]] section for more details.

* License

Copyright © 2019-2020 Aabm <aabm@disroot.org>

Author: Aabm <aabm@disroot.org>
URL: https://gitlab.com/aabm/emacs

This file is NOT part of GNU Emacs.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Emacs; see the file LICENSE.  If not, you can visit
https://www.gnu.org/licenses/gpl-3.0.html or write to the
Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.

** License headers for other files

#+begin_src emacs-lisp :tangle early-init.el
  ;; Copyright © 2019-2020 Aabm <aabm@disroot.org>

  ;; Author: Aabm <aabm@disroot.org>
  ;; URL: https://gitlab.com/aabm/emacs

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 3, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs; see the file LICENSE.  If not, you can visit
  ;; https://www.gnu.org/licenses/gpl-3.0.html or write to the
  ;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  ;; Boston, MA 02110-1301, USA.
#+end_src

#+begin_src emacs-lisp :tangle init.el
  ;; Copyright © 2019-2020 Aabm <aabm@disroot.org>

  ;; Author: Aabm <aabm@disroot.org>
  ;; URL: https://gitlab.com/aabm/emacs

  ;; This file is NOT part of GNU Emacs.

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 3, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs; see the file LICENSE.  If not, you can visit
  ;; https://www.gnu.org/licenses/gpl-3.0.html or write to the
  ;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  ;; Boston, MA 02110-1301, USA.
#+end_src

* Early startup settings

This section contains settings for managing the process of
startup. They affect garbage collection, package management, and the
loading of the GUI. Most of these are done in order to achieve faster
startup times.

** Startup options hack

A fairly simple hack to speed up startup in Emacs. It works by
disabling garbage gollection and the file name handler while Emacs is
starting, then enables them back up once the startup process is
complete.

#+begin_src emacs-lisp :tangle early-init.el
  (defvar startup/file-name-handler-alist file-name-handler-alist)

  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6
        file-name-handler-alist nil)

  (defun startup/reset-defaults ()
    (setq gc-cons-threshold 16777216
          gc-cons-percentage 0.1
          startup/file-name-handler-alist file-name-handler-alist))

  (add-hook 'emacs-startup-hook 'startup/reset-defaults)
#+end_src

** Disabling GUI elements

These settings involve disabling GUI elements like tool, menu and
scroll bars, since I personally do not feel as if they're really
needed. 

#+begin_src emacs-lisp :tangle early-init.el
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)

  (set-window-scroll-bars (minibuffer-window) nil nil)

  (setq frame-inhibit-implied-resize t)
#+end_src

** Disabling package.el

These are settings for disabling =package.el=, Emacs' built-in package
manager. Since Emacs 27, package.el is automatically started before
loading init.el, so it must be disabled in early-init. As mentioned
before, this configuration uses =straight.el=, an external package
manager using a functional paradigm. There is nothing too wrong about
package.el, this choice was made simply because straight offers a few
more conveniences, and is generally faster, easier and more
comfortable to use than package.el.

#+begin_src emacs-lisp :tangle early-init.el
  (setq package-enable-at-startup nil
        package--init-file-ensured t)
#+end_src

** Bootstrapping straight.el

Here we bootstrap the =straight.el= package manager, which replaces
package.el. This requires that =git= be installed on the system.

#+begin_src emacs-lisp :tangle init.el
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** Installing and configuring use-package

In this section we install =use-package=, a collection of macros for
making package management easier and more convenient. Note that
use-package is not a complete package manager unto itself, just a
wrapper around existing tools, that provides great control over the
process of loading a given package. It is also used for configuring
packages, and lazy loading those configurations.

#+begin_src emacs-lisp :tangle init.el
  (straight-use-package 'use-package)

  (setq use-package-always-ensure nil)
  (setq use-package-always-defer t)
  (setq use-package-hook-name-suffix nil)
#+end_src

** Ensuring auto-compilation of all elisp

Here we make sure that Emacs always has access to byte-compiled elisp
instead of simple source files. The first setting here ensures that
outdated byte code files do not get loaded.

The second variable here forces the byte-compiler to ignore all the
warnings relating to the deprecation of the =cl= library, since they
can get annoying.

#+begin_src emacs-lisp :tangle init.el
  (setq load-prefer-newer t
        byte-compile-warnings '(cl-functions))
#+end_src

** Benchmark init

When activated at startup, the package =benchmark-init= records load
times for all other installed packages, then allows the user to
visualize these, in order to acquire the information necessary for
optimizing package declarations.

#+begin_src emacs-lisp :tangle init.el
  (use-package benchmark-init
    :straight t
    :init
    (benchmark-init/activate)
    :hook
    ((after-init-hook . benchmark-init/deactivate)))
#+end_src

* Quality of life changes

This section contains basic changes to Emacs behavior that can be
quite helpful. Configuration here does not involve the use of any
external packages.

** Enabling "advanced" keybindings

Emacs comes by default with some functions disabled from regular use;
calling one of these functions by its respective keybinding will yield
a message reminding the user that these are features recommended only
to advanced users, and that beginners should turn back. To be honest,
I never use any of these features very frequently, but I still don't
want to be confronted by a warning message in the rare case I do use
any of them. So here we enable these functions.

We also take care to disable the =suspend-frame= key, by default bound
to =C-z=. It's useless.

#+begin_src emacs-lisp :tangle init.el
  (put 'dired-find-alternate-file 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (setq disabled-command-function nil)

  (global-set-key (kbd "C-z") nil)
#+end_src

** Text formatting

Here we make sure all possible text encoding is done as UTF-8, which
is the universal standard. We also set code indentation for occasional
programming. I think some of these settings may be redundant, but I
don't mind.

#+begin_src emacs-lisp :tangle init.el
  (prefer-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8) 
  (set-keyboard-coding-system 'utf-8) 
  (set-selection-coding-system 'utf-8) 
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (setq locale-coding-system 'utf-8
        org-export-coding-system 'utf-8) 

  (setq-default tab-width 4) 
#+end_src

** Text display

The settings found here are a bit more varied, but they mostly center
around the way text and information is displayed on screen to the
user: line numbers, line highlighting, line wrapping, etc.

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)

  (show-paren-mode t)

  (setq truncate-lines nil
        org-startup-truncated nil)
  (global-visual-line-mode t)

  (global-prettify-symbols-mode t)
#+end_src

** Some UI settings

These are basic setings related to the GUI. First we disable the
default startup screen, then we enable line and column number display
in the modeline.

#+begin_src emacs-lisp :tangle init.el
  (setq inhibit-startup-message t)

  (line-number-mode t)
  (column-number-mode t)
#+end_src

** Changing defaults

Here we disable or alter undesirable behaviors that Emacs has out of
the box. Most notable are the non-conservative scrolling, by which the
entire buffer will shift once the cursor wraps over the bottom, and
the lack of usage of the X clipboard.

#+begin_src emacs-lisp :tangle init.el
  (setq scroll-conservatively 100

        ring-bell-function 'ignore

        select-enable-clipboard t
        save-interprogram-paste-before-kill t

        make-backup-files nil
        auto-save-default nil

        kill-buffer-query-functions nil
        large-file-warning-threshold nil)

  (defalias 'yes-or-no-p 'y-or-n-p)

  (global-auto-revert-mode t)
#+end_src

** Focus follows mouse

Make the window focus will follow the mouse movement.

#+begin_src emacs-lisp :tangle init.el
  (setq focus-follows-mouse t
        mouse-autoselect-window t)
#+end_src

* Base packages

In this section we install general purpose packages that are
frequently used later. These packages serve as building blocks for
configuration itself, or other packages.

** diminish

=diminish= is a package for disabling the display of minor modes in
the modeline. It works on a per-package basis, and can be called from
use-package declarations.

#+begin_src emacs-lisp :tangle init.el
  (use-package diminish
    :straight t
    :diminish visual-line-mode eldoc-mode org-indent-mode)
#+end_src

** async

=Async= is a library for asynchronous processing for Emacs. By itself it
does not do much, but is actually required by some packages. Here we
use it mostly for enabling asynchronous operations on files when using
Dired and also for compilation of some Elisp.

#+begin_src emacs-lisp :tangle init.el
  (use-package async
    :straight t
    :init
    (dired-async-mode t)
    (async-bytecomp-package-mode t)
    :diminish dired-async-mode)
#+end_src

** gcmh

=gcmh=, or the =garbage collection magical hack= alters the way Emacs'
garbage collection works. In short, it makes Emacs run better by not
wasting as much time garbage collecting. Setting the =gcmh-verbose=
variable to =t= also displays a message everytime any gc happens and
the time wasted by it. This is helpful in realizing just how much time
would normally be wasted with gc.

#+begin_src emacs-lisp :tangle init.el
  (use-package gcmh
    :straight t
    :init
    (gcmh-mode)
    :diminish gcmh-mode
    :custom
    (gcmh-verbose t))
#+end_src

** General

=general.el= is a tool for keybinding declaration. I use it in this
configuration mainly because it has simpler syntax than =define-key=
or =global-set-key=, thus making it easier to make large blocks of
keybinding declarations.

#+begin_src emacs-lisp :tangle init.el
  (straight-use-package 'general)
  (general-auto-unbind-keys)
#+end_src

** Which Key

=which-key= is a core package in many distributed configurations for
Emacs, and not without reason. It helps the user discover keybindings,
default or not, simply by displaying a list of active bindings as the
user types. Very useful for the times you can't remember long series
of bindings.

#+begin_src emacs-lisp :tangle init.el
  (use-package which-key
    :straight t
    :init
    (which-key-mode)
    :diminish which-key-mode
    :custom
    (which-key-show-early-on-C-h t))
#+end_src

** Ivy, Swiper, Avy

=Ivy= is a lightweight but powerful =fuzzy completion= and =narrowing
search framework= for Emacs. It can be used to replace actions like
=find-file= or =switch-buffer=. Here it is paired with =Counsel=,
which adds further replacements for default actions. We replace the
default actions in this config, by simply overwriting default
keybindings with Counsel actions. =Ivy-rich= adds a few more bits of
information to Ivy menus, like a function description when using
counsel-M-x. 

=Swiper= is a search tool, for searching for text or regex
in-buffer. It pairs nicely with Ivy and Counsel. There is also =Avy=,
which is a buffer navigation tool using narrowing completion. Both of
these are later bound to keys.

#+begin_src emacs-lisp :tangle init.el
  (use-package ivy
    :straight ivy swiper counsel swiper avy ivy-rich
  
    :init
    (ivy-mode)
    (counsel-mode)
    (ivy-rich-mode)
  
    :diminish ivy-mode counsel-mode ivy-rich-mode
  
    :custom
    (enable-recursive-minibuffers t)
  
    :bind
    (("C-s" . swiper)
     ("C-r" . swiper-backward)
     ("M-s s" . avy-goto-char-2)
     ("C-x C-f" . counsel-find-file)
     ("C-x b" . counsel-switch-buffer)
     ("C-x r b" . bookmark-jump)
     ("M-x" . counsel-M-x)
     ("C-h f" . counsel-describe-function)
     ("C-h v" . counsel-describe-variable)
     ("C-h o" . counsel-describe-symbol)))
#+end_src

* Custom keybinding system

** Prefix keys

Here we define all prefix keys. The setup here is similar to the
leader key system present in =Spacemacs= or =Doom Emacs=, except made
for use with regular Emacs keys.

#+begin_src emacs-lisp :tangle init.el
  (define-prefix-command 'leader)
  (define-prefix-command 'agenda-and-time)
  (define-prefix-command 'buffers)
  (define-prefix-command 'database)
  (define-prefix-command 'fill-text)
  (define-prefix-command 'music)
  (define-prefix-command 'notes)
  (define-prefix-command 'password-management)
  (define-prefix-command 'search+)
  (define-prefix-command 'text-editing)
  (define-prefix-command 'youtube)

  (global-set-key (kbd "C-c c") 'leader)
  (global-set-key (kbd "C-c b") 'buffers)
  (global-set-key (kbd "C-c f") 'fill-text)
  (global-set-key (kbd "C-c n") 'notes)
  (global-set-key (kbd "C-c t") 'text-editing)

  (general-define-key
   :keymaps 'leader
   "a" 'agenda-and-time
   "b" 'buffers
   "d" 'database
   "f" 'fill-text
   "m" 'music
   "n" 'notes
   "p" 'password-management
   "s" 'search+
   "t" 'text-editing
   "y" 'youtube)
#+end_src

* Text editing

Under this section we put all configurations and packages that expand
Emacs' text editing capabilities. These mostly refer to editing motions
and styles defined by minor modes, not major modes.

** Electric pairs

Electric pairs is a tool for adding matching
closing characters after point once you insert an opening
character. Useful for parentheses, brackets, braces and quotation
marks.

#+begin_src emacs-lisp :tangle init.el
  (setq electric-pair-pairs '(
							 (?\{ . ?\})
							 (?\( . ?\))
							 (?\[ . ?\])
							 (?\" . ?\")
							 ))

  (electric-pair-mode t)
#+end_src

** Expand region
=expand-region= is a package for selecting text based on expanding
regions. In simple terms, it marks a region and allows you to expand
that region from small to large, word to line to paragraph. In many
ways, expand region can be used similarly to Vim's delete/change
inside/around commands. 

#+begin_src emacs-lisp :tangle init.el
  (use-package expand-region
    :straight t
    :bind
    (("C-=" . er/expand-region)))
#+end_src

** Surround

A utility for editing text surrounding other text, like parentheses,
brackets, quotation marks, etc. Inspired by Vim's =surround= plugin.

#+begin_src emacs-lisp :tangle init.el
  (use-package emacs-surround
    :straight (:host github :repo "ganmacs/emacs-surround")
    :bind
    ("C--" . emacs-surround))
#+end_src

** Hungry delete

=hungry-delete= is a utility for making deletion of long bits of
whitespace easier.

#+begin_src emacs-lisp :tangle init.el
  (use-package hungry-delete
    :straight t
    :init
    (global-hungry-delete-mode)
    :diminish hungry-delete-mode)
#+end_src

** Multiple cursors

=multiple-cursors= is pretty self-explanatory. It allows the user to
control multiple cursors at the same time, one for each selected
line. 

#+begin_src emacs-lisp :tangle init.el
  (use-package multiple-cursors
    :straight t
    :commands mc/edit-lines
    :bind
    (:map text-editing
     ("m" . mc/edit-lines)))
#+end_src

** Writable grep

=wgrep= allows one to =grep= through a file or directory, edit the
output of grep, then write the changes into the files.

#+begin_src emacs-lisp :tangle init.el
  (use-package wgrep
    :straight t
    :commands wgrep
    :custom
    (wgrep-auto-save-buffer t)
    (wgrep-change-readonly-file t)
    :bind
    (:map grep-mode-map
          (("C-x C-q" . wgrep-change-to-wgrep-mode))))
#+end_src

** Filling text

A few simple options for filling text to a reasonable character/column
limit.

#+begin_src emacs-lisp :tangle init.el
  (general-define-key
   :keymaps 'fill-text
   "a" 'auto-fill-mode
   "f" 'fill-region)
#+end_src

** Undo Tree

=undo-tree= expands the possibilities of undoing and redoing edits by
allowing the user to interact more with Emacs' undo tree system.

#+begin_src emacs-lisp :tangle init.el
  (use-package undo-tree
    :straight t
    :init
    (global-undo-tree-mode)
    :diminish undo-tree-mode)
#+end_src

** Sudo edit

Easily open files over sudo using =TRAMP=.

#+begin_src emacs-lisp :tangle init.el
  (use-package auto-sudoedit
    :straight t
    :diminish
    :init
    (auto-sudoedit-mode))
#+end_src

** Isearch

#+begin_src emacs-lisp :tangle init.el
  (general-define-key
   :keymaps 'search+
   "s" 'isearch-forward)
#+end_src

* Buffer, file and window management

In this section we deal with all packages relating to the fundamental
components of any Emacs workflow, those being buffers, files and
windows.

** Buffers

For =buffers=, we change keybindings and configure a few useful
utilities for managing them, such as =ibuffer=.

*** Ibuffer

=Ibuffer= is a general utility for managing buffers, in a similar
manner to the way =dired= handles files and directories. The
customizations here involve adding icons and keybindings to
=ibuffer-mode=.

#+begin_src emacs-lisp :tangle init.el
  (use-package ibuffer
    :commands ibuffer
    :bind
    (("C-x C-b" . ibuffer)))
#+end_src

*** Genbuffer

This loads my own package contain a few functions for easily
generating =scratch buffers=, whether they be in =org-mode= or in
=lisp-interaction-mode= or something else.

#+begin_src emacs-lisp :tangle init.el
  (use-package genbuffer
    :load-path "elisp/genbuffer.el"
    :bind
    (:map buffers
          ("o" . genbuffer-org)
          ("s" . genbuffer-scratch)
          ("t" . genbuffer-text)
          ("h" . genbuffer-html)))
#+end_src

*** Kill this buffer

#+begin_src emacs-lisp :tangle init.el
  (defun aabm/kill-this-buffer ()
    "Kill the current buffer."
    (interactive)
    (kill-buffer))
#+end_src

*** Kill buffer and window

This function kills the current buffer, along with the window in which
it is being displayed.

#+begin_src emacs-lisp :tangle init.el
  (defun aabm/kill-this-buffer-and-window ()
    "Kill the current buffer and its corresponding window."
    (interactive)
    (progn
      (kill-buffer)
      (delete-window)))
#+end_src

*** Keybindings

#+begin_src emacs-lisp :tangle init.el
  (general-define-key
   "C-x k" 'aabm/kill-this-buffer
   "C-x C-k" 'aabm/kill-this-buffer-and-window)
#+end_src

** Windows

Here are all the settings involving window management. We define a few
custom functions and also install a few packages.

*** Split-and-follow windows

The first thing we do here is change the window split behavior. We
replace the default functions with functions that automatically switch
to the new window.

#+begin_src emacs-lisp :tangle init.el
  (defun aabm/split-follow-window-below ()
    "Creates a window below and automatically switches to it. Meant to be used as a replacement for split-window-below."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun aabm/split-follow-window-right ()
    "Creates a window to the right and automatically switches to it. Meant to be used as a replacement for split-window-right."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (general-define-key
   "C-x 2" 'aabm/split-follow-window-below
   "C-x 3" 'aabm/split-follow-window-right)
#+end_src

*** Eyebrowse

Eyebrowse is a simple package for managing multiple window
configurations, similar to the workspaces in tiling window managers.

#+begin_src emacs-lisp :tangle init.el
  (use-package eyebrowse
    :straight t
    :init
    (eyebrowse-mode)
    :bind
    (("C-c C-w 0" . eyebrowse-close-window-config)))
#+end_src

*** Windmove

=windmove= allows easy switching between windows by using shift +
arrow keys.

#+begin_src emacs-lisp :tangle init.el
  (windmove-default-keybindings)
#+end_src

*** Keybindings

This key makes it easier to switch windows.

#+begin_src emacs-lisp :tangle init.el
  (global-set-key (kbd "M-o") 'other-window)
#+end_src

** Files

*** Dired

=dired=, or the =directory editor= is Emacs' built in file manager.

#+begin_src emacs-lisp :tangle init.el
  (use-package dired
    :straight peep-dired dired-subtree dired-hide-dotfiles 
    :commands dired

    :custom
    (dired-dwim-target t)
    (dired-recursive-copies 'always)
    (dired-recursive-deletes 'always)  
    (dired-listing-switches "-alhvNF --group-directories-first")

    (wdired-allow-to-change-permissions t)

    (peep-dired-cleanup-on-disable t)
    (peep-dired-ignored-extensions '("mkv" "iso" "mp4"))

    :config

    (defun aabm/dired-xdg-open ()
      "Open the marked files using xdg-open."
      (interactive)
      (let ((file-list (dired-get-marked-files)))
        (mapc
         (lambda (file-path)
           (let ((process-connection-type nil))
             (start-process "" nil "xdg-open" file-path)))
         file-list)))

    (defun aabm/dired-up-alternate-directory ()
      "Move up a directory, reusing the current buffer, instead of creating a new one."
      (interactive)
      (find-alternate-file ".."))

    :hook
    ((dired-mode-hook . dired-hide-details-mode)
     (dired-mode-hook . dired-hide-dotfiles-mode)
     (dired-mode-hook . hl-line-mode))

    :diminish dired-hide-dotfiles-mode

    :bind
    (:map dired-mode-map
          (("RET" . dired-find-alternate-file)
           ("M-RET" . dired-find-file)
           ("DEL" . aabm/dired-up-alternate-directory)
           ("TAB" . dired-subtree-insert)
           ("C-c d m" . mkdir)
           ("C-c d c" . chmod)
           ("h" . dired-hide-dotfiles-mode)
           ("H" . dired-hide-details-mode)
           ("i" . peep-dired)
           ("I" . image-dired)
           ("v" . aabm/dired-xdg-open)
           ("q" . kill-this-buffer))))

  (use-package peep-dired
    :straight t
    :bind
    (:map dired-mode-map
          (("i" . peep-dired)))
    (:map peep-dired-mode-map
          (("n" . peep-dired-next-file)
           ("p" . peep-dired-prev-file))))
#+end_src

*** Magit

=Magit= is a complete =git= frontend for Emacs. It makes usage of git
significantly easier and more intuitive. No more typing esoteric shell
commands you barely understand.

#+begin_src emacs-lisp :tangle init.el
  (use-package magit
    :straight t
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    :bind
    (("C-x g" . magit-status)))
#+end_src

*** Loading files conditionally

This is a simple function for loading files conditionally (that is,
only if they exist). Simply put, it makes the process of loading
external files such as those containing personal information not
included in this config, a lot easier.

#+begin_src emacs-lisp :tangle init.el
(defun aabm/load-file-if (file)
  "Check if FILE exists, and if so, load it."
  (if (file-exists-p file)
    (load-file file)))
#+end_src

* Writing, notetaking and reading

Under this section are all the configuration and packages relating to
=reading= (books, papers, documents) and =writing= (notetaking, document
production, word processing). As one might expect, this section is
mainly centered around =org-mode=, as well as any packages that
contribute org workflows.

** Olivetti and Writeroom

Before we get to any further customization on the reading/writing
workflow, we install a few packages that make that experience a bit
more focused. First is =olivetti-mode=, which is a simple mode for
centering text in the buffer. It will later be used along with some
major modes, in order to improve their readability. 

The second package is =writeroom-mode=, which is, in some ways, an
expanded version of olivetti (though they share no code). Writeroom,
when called, not only centers text in the current buffer, but also
kills all other windows, fullscreens the current frame, and eliminates
all transparency. This is done to provide a focused experience for
reading and writing.

#+begin_src emacs-lisp :tangle init.el
  (use-package olivetti
    :straight t
    :bind
    (("C-c o" . olivetti-mode)
     (:map fill-text
           ("o" . olivetti-mode))))

  (use-package writeroom-mode
    :straight t
    :bind
    (:map fill-text
          ("w" . writeroom-mode)))
#+end_src

** Org

Now for =org-mode=. Org is one of the central packages in this
configuration, so we will do a lot of customization to it.

*** Essential configuration

First, we ensure the latest version of org is installed, then change
some basic options. These are:
- Setting the default directory for org files
- Changing the ellipsis for better looking headings
- Hiding leading stars in headings
- Adding nice visual indentation to all org buffers
- Better keybindings for heading navigation

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :straight t
    :init
    (setq org-export-backends '(ascii beamer html latex md))
    :defer t

    :custom
    (org-directory "~/org/")
    (org-ellipsis "⬎")
    (org-hide-leading-stars t)
    (org-html-postamble nil)
    (org-cycle-global-at-bob t)

    :hook
    (org-mode-hook . org-indent-mode)
  
    :diminish org-indent-mode

    :bind
    (("C-," . org-cycle-agenda-files)
     (:map org-mode-map
          (("M-n" . org-forward-element)
           ("M-p" . org-backward-element)
           ("C-M-n" . org-metadown)
           ("C-M-p" . org-metaup)
           ("C-M-f" . org-metaright)
           ("C-M-b" . org-metaleft)
           ("<mouse-3>" . org-cycle)
           ("<S-right>" . nil)
           ("<S-left>" . nil)
           ("<S-down>" . nil)
           ("<S-up>" . nil)))))
#+end_src

*** Agenda, Tasks and TODOs

This section revolves entirely around the =org-agenda=, along with all
handling of tasks and TODOs.

First, we:
- Set default agenda directory
- Setting the archive file, where all completed tasks will be stored
- Ensure tasks cannot be completed if they have unfinished dependencies
- Add a timestamp to all completed tasks

Finally, we define a few custom functions: one that automatically
marks the current task as DONE, then sends it to the archive, and
another for quickly opening up the main agenda file.

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :custom
    (org-agenda-files '("~/org/agenda/home.org"
                        "~/org/agenda/uni.org"))
    (org-archive-location (concat org-directory "/archive.org::"))
    (org-enforce-todo-dependencies t)
    (org-enforce-todo-checkbox-dependencies t)
    (org-log-done 'time)
    (org-agenda-window-setup 'only-window)
    (org-link-frame-setup '((vm . vm-visit-folder-other-frame)
                            (vm-imap . vm-visit-imap-folder-other-frame)
                            (gnus . org-gnus-no-new-news)
                            (file . find-file)
                            (wl . wl-other-frame)))

    :bind
    (:map agenda-and-time
          ("a" . org-agenda)))

  (defun aabm/org-todo-done-and-archive ()
    "Sets current org task do DONE and sends it to org-archive-location."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))
#+end_src

*** Capture

Here we define the file where captured notes will be stored by
default, as well as the templates to use for capture.

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :custom
    (org-capture-bookmark nil)
    (org-default-notes-file (concat org-directory "agenda.org"))
    (org-capture-templates
     '(
       ("u" "Uni")
       ("ut" "Uni - Trabalhos"
        entry
        (file+headline "agenda/uni.org" "Trabalhos")
        "* TODO Trabalho de %^{Disciplina|Política|Antropologia|Sociologia|Demografia|Estatística} - %^{ITEM}\n%?\nDEADLINE: %^T")

       ("ul" "Uni - Leituras"
        entry
        (file+headline "agenda/uni.org" "Leituras")
        "* TODO Leitura de %^{Disciplina|Política|Antropologia|Sociologia|Demografia|Estatística} - %^{ITEM}\n%?\nDEADLINE: %^T")

       ("l" "List of")
       ("lb" "Books"
        entry
        (file "list/books.org")
        "* %^{Status|PLAN|READING|READ} %^{Title}\n\n** Info\n:TIME: %t\n:AUTHOR: %^{Author}\n:YEAR: %^{Year of publication}\n:SERIES: %^{Series}\n:LANG: %^{Language|Português|English|Español|Deutsch}\n:PUBL: %^{Publisher}\n\n** Thoughts\n%?")

       ("ll" "Library"
        entry
        (file "list/library.org")
        "* %^{Status|HOME|BORROWED|LENT|GONE} %^{Title}\n\n** Info\n\n:AUTHOR: %^{Authors}\n:SORT: %^{Author Sort}\n:SERIES: %^{Series}\n:NUMBER: %^{Number in series}\n:PUBL: %^{Publisher}\n:LANG: %^{Language|Português|English|Español}\n:CONDITION: %^{Condition|New|Good|Medium|Worn|Fucked}\n:SHELF: %^{Shelf|Fiction|Non-fiction|Manga|Other}\n:SOURCE: %^{Source|Gift:|Purchase:} %?\n\n** Log\n\n")

       ("la" "Anime"
        entry
        (file "list/anime.org")
        "* %^{Status|PLAN|WATCHING|SEEN|DROPPED} %^{Title}\n:TIME: %t\n:STUDIO: %^{Studio}\n:DIRECTOR:\n:YEAR: %^{Year}\n:SEASON: %^{Season}\n")

       ("lb" "Books"
        entry
        (file "list/books.org")
        "* %^{Status|PLAN|READING|READ} %^{Title}\n:TIME: %t\n:AUTHOR: %^{Author}\n:YEAR: %^{Year of publication}\n:SERIES: %^{Series}\n:LANG: %^{Language}\n:PUBL: %^{Publisher}\n")

       ("h" "Home maintenance"
        entry
        (file "agenda/home.org")
        "* TODO %^{ITEM}\n%?\nDEADLINE: %^T")))

    :bind
    (("C-c w" . org-capture)))
#+end_src

*** Structure blocks

These are the settings regarding org's structure blocks (src, quote,
etc) and the templates for quickly creating them. First we enable
proper indentation and syntax highlighting in source blocks, then make
it so that editing src blocks in their own buffer does not create a
new window, rather take up the current one. Finally, we define
structure templates for creating blocks.

#+begin_src emacs-lisp :tangle init.el
  (use-package org
    :custom
    (org-src-tab-acts-natively t)
    (org-src-fontify-natively t)
    (org-src-window-setup 'current-window)
    (org-structure-template-alist
          '(("c" . "center\n")
            ("e" . "src emacs-lisp :tangle init.el\n")
            ("h" . "export html\n")
            ("l" . "export latex\n")
            ("q" . "quote\n")
            ("r" . "src R :results output :export results\n")
            ("s" . "src")
            ("v" . "verse\n"))))
#+end_src

*** Literate programming

This makes org babel load all the appropriate language packages,
allowing for literate programming.

#+begin_src emacs-lisp :tangle init.el
  (setq org-confirm-babel-evaluate nil)

  (setq org-babel-load-languages
   '((R . t)
     (python . t)
     (emacs-lisp . t)
     (shell . t)
     (org . t)
     (latex . t)))
#+end_src

*** Org Roam

=org-roam= is a very powerful extension to org-mode. Essentially, it
is a package that maintains a relational database of links between
files, and allows navigation of this database using links and
backlinks. Org Roam is made as a tool for notetaking following the
=zettelkasten= method. It is quite a useful tool, and I personally
treat it as a second brain, in which I store all my information.

We also install =org-roam-server=, which runs a simple local web
server for displaying a visual representation of links between notes.

The final package installed is =deft=, a search tool for org
files. All these packages can be acessed under the C-c n map.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-roam
    :straight t

    :config
    (require 'org-protocol)
    (require 'org-roam-protocol)
    (org-roam-mode)

    :diminish org-roam-mode

    :custom
    (org-roam-directory "~/org/roam/")
    (org-roam-index-file "~/org/roam/index.org")
    (org-roam-encrypt-files nil)
    (org-roam-completion-system 'ivy)
    (org-roam-db-update-method 'immediate)
    (org-roam-graph-executable "/usr/bin/neato")
    (org-roam-graph-extra-config '(("overlap" . "false")))
    (org-roam-capture-templates
     '(("t" "tagged" plain (function org-roam--capture-get-point)
        "#+date:%T\n#+startup: overview\n#+roam_tags: %?\n#+roam_alias:"
        :file-name "%<%Y%m%d%H%M%S>-${slug}"
        :head "#+title: ${title}\n"
        :unnarrowed t)))

    :bind
    (:map notes
     ("f" . org-roam-find-file)
     ("l" . org-roam-insert)
     ("c" . org-roam-random-note)
     ("d" . org-roam-dailies-date)))

  (use-package org-roam-server
    :straight t
    :custom
    (org-roam-server-host "127.0.0.1")
    (org-roam-server-port 8080)
    (org-roam-server-authenticate nil)
    (org-roam-server-export-inline-images t)
    (org-roam-server-serve-files nil)
    (org-roam-server-served-file-extensions '("pdf" "mp4" "ogv"))
    (org-roam-server-network-poll t)
    (org-roam-server-network-arrows nil)
    (org-roam-server-network-label-truncate t)
    (org-roam-server-network-label-truncate-length 60)
    (org-roam-server-network-label-wrap-length 20)
    :bind
    (:map notes
          ("g" . org-roam-server-mode)))

  (use-package deft
    :straight t
    :custom
    (deft-recursive t)
    (deft-use-filter-string-for-filename t)
    (deft-default-extension "org")
    (deft-directory "~/org/roam")
    :bind
    (:map notes
     ("s" . deft)))
#+end_src

*** Org Superstar

=org-superstar= is a package that replaces the asterisks in org
headings with nice looking Unicode characters.

#+begin_src emacs-lisp :tangle init.el
  (use-package org-superstar
    :straight t
    :hook
    (org-mode-hook . org-superstar-mode))
#+end_src

** LaTeX

*** AucTeX

#+begin_src emacs-lisp :tangle init.el
  (use-package auctex
    :straight t
    :custom
    (TeX-PDF-mode t)
    (TeX-view-program-selection '((output-pdf "pdf-tools")))
    (TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))
    (TeX-source-correlate-mode t)
    (TeX-source-correlate-start-server t)

    :hook
    (TeX-after-compilation-finished-functions . TeX-revert-document-buffer)
    (LaTeX-mode-hook . turn-on-auto-fill))
    (LaTeX-mode-hook . (lambda () (set (make-variable-buffer-local
                                   'TeX-electric-math)
                                  (cons "\\(" "\\)"))))))
#+end_src

** Markdown

I don't really use =Markdown=, since org is a much superior markup
language, but occasionally I need to open a .md file, and for that I
would like to have syntax highlighting. So here we install
=markdown-mode=.

#+begin_src emacs-lisp :tangle init.el
  (use-package markdown-mode
    :straight t)
#+end_src

** Reading PDFs and EPUBs

Emacs can serve as a great tool for reading books. In this section we
configure it as a PDF reader, with the help of the =pdf-tools=
package, and as an EPUB reader, with the =nov.el= package.

*** PDF Tools

The configurations for pdf-tools here simply involve the zooming, page
fit and continuity of pages. We also ensure that pdf-tools is able to
install and configure its external binary on first startup.

The first function, =aabm/pdf-view-continuous-toggle= is made for
toggling the page continuity. With that off, scrolling over a page
will not take you to the next page, you must do that explicitly.

The second function, =aabm/pdf-view-open-in-zathura= allows opening
the current pdf in the external viewer called =zathura=. This function
can easily be changed to use any other viewer, like =evince= or
=okular=.

Finally, the third function, =aabm/pdf-view-print-current-page=, exists
for printing the current page number to the echo area.

#+begin_src emacs-lisp :tangle init.el
  (use-package pdf-tools
    :straight t
    :init
    (pdf-loader-install)
    :config

    (defun aabm/pdf-view-continuous-toggle ()
      (interactive)
      (cond ((not pdf-view-continuous)
             (setq pdf-view-continuous t)
             (message "Page scrolling: Continous"))
            (t
             (setq pdf-view-continuous nil)
             (message "Page scrolling: Constrained"))))

    (defun aabm/pdf-view-open-in-zathura ()
      "Open the current PDF with ‘zathura’."
      (interactive)
      (save-window-excursion
        (let ((current-file (buffer-file-name))
              (current-page (number-to-string (pdf-view-current-page))))
          (async-shell-command
           (format "zathura -P %s \"%s\"" current-page current-file))))
      (message "Sent to Zathura"))

    (defun aabm/pdf-view-show-current-page ()
      "Print the current page."
      (interactive)
      (message "Page: %s" (pdf-view-current-page)))

    (defun pdfgrep ()
      (interactive)
      (grep (format "pdfgrep --ignore-case --recursive --page-number '%s' ." (read-string "Enter term: "))))  

    :custom
    (pdf-view-resize-factor 1.1)
    (pdf-view-continuous nil)
    (pdf-view-display-size 'fit-page)
    :bind
    (:map pdf-view-mode-map
          ("C-s" . isearch-forward)
          ("C-r" . isearch-backward)
          ("C-c d" . pdf-view-midnight-minor-mode)
          ("C-c z" . aabm/pdf-view-open-in-zathura)
          ("C-c p" . aabm/pdf-view-show-current-page)
          ("C-c t" . aabm/pdf-view-continuous-toggle )
          ("C-a" . image-scroll-right)
          ("C-e" . image-scroll-left)
          ("f" . pdf-view-goto-page)))
#+end_src

*** nov.el

Now we install =nov.el=, which is a small package for reading .epub
files with Emacs. The only significant configuration done here is
hooking nov.el to olivetti-mode.

#+begin_src emacs-lisp :tangle init.el
  (use-package nov
    :straight t
    :init
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
    :bind
    (:map nov-mode-map
            (("M-n" . scroll-up-line)
            ("M-p" . scroll-down-line))))
#+end_src

** CalibreDB

=calibredb= offers an Emacs interface for the =Calibre= ebook
manager. The package allows for interacting with a Calibre database
entirely from within Emacs, without ever having to bother touching the
(horrible) interface for calibre.

#+begin_src emacs-lisp :tangle init.el
  (use-package calibredb
    :straight t
    :defer t
    :custom
    (calibredb-root-dir "~/doc/books")
    (calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir))
    (calibredb-library-alist '(("~/doc/books")))
    (calibredb-format-all-the-icons t)
    :bind
    (:map database
          ("l" . calibredb)
          ("s" . calibredb-find-counsel)
          ("a" . calibredb-add))
    (:map calibredb-search-mode-map
          ("t" . calibredb-set-metadata-dispatch)
          ("s" . calibredb-search-live-filter)
          ("n" . calibredb-next-entry)
          ("p" . calibredb-previous-entry)
          ("j" . nil)
          ("k" . nil)))
#+end_src

* Personal agenda, time and task management

** Time display

#+begin_src emacs-lisp :tangle init.el
  (use-package time
    :commands world-clock display-time-world
    :custom
    (display-time-format "%a, %b %d %H:%M")
    (display-time-interval 60)
    (display-time-mail-directory nil)
    (display-time-default-load-average t)

    (zoneinfo-style-world-list
     '(("America/Los_Angeles" "-8 Seattle")
       ("America/New_York" "-5 New York")
       ("America/Sao_Paulo" "-3 Brasília")
       ("Europe/London" "+0 London")
       ("Europe/Brussels" "+1 Berlin")
       ("Europe/Moscow" "+3 Baghdad")
       ("Asia/Shanghai" "+8 Shanghai")
       ("Asia/Tokyo" "+9 Tokyo")))

    :hook
    (after-init-hook . display-time-mode)

    :bind
    (:map agenda-and-time
     ("t" . display-time-world)))
#+end_src

** Calendar

#+begin_src emacs-lisp :tangle init.el
  (use-package calendar
    :commands calendar
    :custom
    (calendar-week-start-day 0)
    (calendar-day-name-array ["Domingo" "Segunda" "Terça" "Quarta" 
                              "Quinta" "Sexta" "Sábado"])
    (calendar-month-name-array ["Janeiro" "Fevereiro" "Março" "Abril"
                                "Maio" "Junho" "Julho" "Agosto"
                                "Setembro" "Outubro" "Novembro" "Dezembro"])
    :bind
    ((:map agenda-and-time
           ("c" . calendar))))
#+end_src

** User credentials

This section loads my personal credentials file. The contents of the
file are minimal, but are kept separate from this file so that
distribution of this configuration does not contain any personal
information that I'd rather not leak to the public.

#+begin_src emacs-lisp :tangle init.el
  (aabm/load-file-if (concat user-emacs-directory "creds.el"))
#+end_src

If you wish to use the above setting, simply create a file in your
user-emacs-directory with the name "creds.el.gpg" containing something
like the example below:

#+begin_src emacs-lisp 
  Example setting for a credentials file:
  (setq user-full-name "Your Name Here"
        user-mail-address "your@email.here"
        calendar-latitude 00.00
        calendar-longitude 000.00
        calendar-location-name "City, State")
#+end_src

* Programming

Here are all the configurations oriented exclusively around
=programming=. These are mainly just simple =use-package= declarations
for programming major modes, which is really all I need.

** General options

*** Compile command

#+begin_src emacs-lisp :tangle init.el
  (global-set-key (kbd "C-c x") 'compile)
#+end_src

*** Rainbow delimiters

#+begin_src emacs-lisp :tangle init.el
  (use-package rainbow-delimiters
    :straight t
    :hook
    ((prog-mode-hook . rainbow-delimiters-mode)))
#+end_src

** Company

#+begin_src emacs-lisp :tangle init.el
  (use-package company
    :straight t
    :diminish company-mode
    :custom
    (company-idle-delay 0)
    (company-minimum-prefix-length 3)
    :bind
    ((:map company-active-map
           ("M-n" . nil)
           ("M-p" . nil)
           ("C-n" . company-select-next)
           ("C-p" . company-select-previous)
           ("SPC" . (lambda () (interactive) (progn (company-abort) (insert " "))))))

    :hook
    (prog-mode-hook . company-mode))
#+end_src

** C

#+begin_src emacs-lisp :tangle init.el
  (use-package company-c-headers
    :straight t
    :defer nil)

  (add-hook 'c-mode-hook
            (lambda ()
              (setq-local compile-command "cc -Wall --stdc99 -ledit")))
#+end_src

** R

#+begin_src emacs-lisp :tangle init.el
  (use-package ess
    :straight t)
#+end_src

** Lisp

=Lisp is the most powerful programming language=. Under this section
are configurations for all =Lisp= programming, whether =Emacs Lisp=,
=Common Lisp= or some variant of =Scheme=. I normally don't use
anything besides Elisp on a regular basis, but you never know. Also
included here are the configurations that help in the process of
configuring Emacs.

*** SICP

The famous meme-book =Structure and Interpretation of Computer
Programs= or more commonly, =SICP=, has a whole Emacs package just for
itself. The package provides a .info file, which can be comfortably
read from Emacs using the =info= command, or C-h i.

#+begin_src emacs-lisp :tangle init.el
  (use-package sicp
    :straight t)
#+end_src

*** Rebuilding Emacs configuration

This is a function for easily =rebuilding my Emacs config=. It
tangles all code blocks then byte-compiles the necessary files. Note
that it does not load these files.

#+begin_src emacs-lisp :tangle init.el
  (defun aabm/build-emacs ()
    "This function is used for completely rebuilding the Emacs configuration file after changes are made to it. 

  It saves the configuration buffer, tangles all the code, then byte-compiles it."
    (interactive)
    (let ((prog-mode-hook nil))
      (save-buffer "emacs.org")
      (org-babel-tangle-file (concat user-emacs-directory "emacs.org"))

      (delete-file (concat user-emacs-directory "early-init.elc"))
      (async-byte-compile-file (concat user-emacs-directory "early-init.el"))

      (delete-file (concat user-emacs-directory "init.elc"))	
      (async-byte-compile-file (concat user-emacs-directory "init.el"))

      (message "Emacs configuration succesfully rebuilt!")))

  (general-define-key
   "H-c e" 'aabm/build-emacs)
#+end_src
 
* Shell and terminal emulation

Emacs comes with a few different solutions for shell and terminal
emulation built in. First and foremost, there is =M-x shell=, which is
a simple utility for running an external shell within Emacs, with the
advantage that it can be treated as a normal text buffer. =shell= can
also be used to power a REPL in other languages.

There is also =eshell= which on the surface is similar to shell, but
is, on the contrary, a much more powerful utility. =eshell= is a full
reimplementation of a /mostly/ POSIX-compliant shell, meaning it uses
its own version of programs like =ls=. This in turn means it is
system-agnostic, and can provide shell utilities even in system that
do not have them. Besides that, it can also read normal expressions in
=emacs lisp=, giving it a lot more flexibility. It is, as expected,
highly customizable, and we take advantage of that here, writing a lot
of custom functions to leverage eshell's power.

There are also /terminal/ emulation programs built into Emacs, namely
=term= and =ansi-term=, which are honestly not very good. As a
replacement, we install =vterm=, which fixes most of the flaws with
the built-in ones, while also allowing use of TUI programs.

** Eshell

#+begin_src emacs-lisp :tangle init.el
  (use-package esh-mode
    :commands eshell
    :config
    (aabm/load-file-if "elisp/eshell.el")
    :custom
    (eshell-prompt-regexp "^[^αλ\n]*[αλ] ")
    (eshell-prompt-function
     (lambda nil
       (concat
        (if (string= (eshell/pwd) (getenv "HOME"))
            (propertize "~" 'face `(:foreground "#458588"))
          (replace-regexp-in-string
           (getenv "HOME")
           (propertize "~" 'face `(:foreground "#458588"))
           (propertize (eshell/pwd) 'face `(:foreground "#458588"))))
        (if (= (user-uid) 0)
            (propertize " α " 'face `(:foreground "#CC241D"))
          (propertize " λ " 'face `(:foreground "#98971A"))))))
    (eshell-banner-message "")
    (eshell-highlight-prompt nil)

    (eshell-cd-on-directory t)

    :bind
    (("C-x s" . eshell)
     (:map aabm/eshell-minor-mode-map
           ("C-c w" . aabm/eshell-copy-file-path-at-point)
           ("C-c f" . aabm/eshell-find-file-at-point)
           ("C-c o" . aabm/eshell-cat-file-at-point)
           ("C-c C-b" . aabm/eshell-put-last-output-to-buffer))))
#+end_src

** Vterm

#+begin_src emacs-lisp :tangle init.el
  (defun aabm/switch-to-vterm-p ()
    (interactive)
    (if
        (get-buffer "vterm")
        (switch-to-buffer "vterm")
      (vterm)))

  (use-package vterm
    :straight t
    :bind
    (("C-x v" . aabm/switch-to-vterm-p)
     ("C-x C-v" . vterm)))
#+end_src

* Security, news, email and web browsing

This section includes all customization necessary for using Emacs as a
mail client with =mu4e=, mailing list reader with =Gnus=, RSS news
reader =Elfeed= and text-based web browser, with =eww=. Many of these
settings are somehow security related.

** Password management

Here we set up a convenient interface for =pass=, the standard Unix
password manager. This interface allows for completion using the
standard completion mechanism, which for this configuration is Ivy.

#+begin_src emacs-lisp :tangle init.el
  (use-package password-store
    :straight pass
    :commands
    (password-store-insert
     password-store-copy
     password-store-edit
     pass)
    :bind
    (:map password-management
          ("i" . password-store-insert)
          ("w" . password-store-copy)
          ("e" . password-store-edit)
          ("p" . pass)))
#+end_src

** Elfeed

=Elfeed= is a complete RSS/Atom feed reader for Emacs. The
configurations applied here are not so complex. First, we have elfeed
load an external file containing all feeds. Then, there is a function
definition for opening video feed links (youtube, invidious) in an
external video player, namely =mpv=, which is bound to the v key.

#+begin_src emacs-lisp :tangle init.el
  (aabm/load-file-if (concat user-emacs-directory "feeds.el"))

  (use-package elfeed
    :straight t
    :config
    (defun aabm/elfeed-play-with-mpv ()
      "Play entry link with mpv."
      (interactive)
      (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
            (quality-arg "")
            (quality-val (completing-read "Max height resolution (0 for unlimited): " '("0" "480" "720") nil nil)))
        (setq quality-val (string-to-number quality-val))
        (message "Opening %s with height≤%s with mpv..." (elfeed-entry-link entry) quality-val)
        (when (< 0 quality-val)
          (setq quality-arg (format "--ytdl-format=[height<=?%s]" quality-val)))
        (start-process "elfeed-mpv" nil "mpv" quality-arg (elfeed-entry-link entry))))

    :custom
    (shr-width 100)

    :bind
    (("C-c e" . elfeed)
     (:map elfeed-show-mode-map
           ("M-n" . scroll-up-line)
           ("M-p" . scroll-down-line)
           ("v" . aabm/elfeed-play-with-mpv))

     (:map elfeed-search-mode-map
           ("v" . aabm/elfeed-play-with-mpv))))
#+end_src

** mu4e

=mu4e= is a full featured mail client for Emacs. It requires use of
external tools, namely:
- A tool for pulling mail from the server, like =isync=
- A tool for sending mail over SMTP, like =msmtp=
- =mu=, which is mu4e's own mail indexing and search tool

The settings contained in this block basically set mu4e up for usage
of those tools.

#+begin_src emacs-lisp :tangle init.el
  (use-package mu4e
    :straight t
    :commands mu4e mu4e-compose-new
    :custom
    (mu4e-maildir "~/.mail/disroot/")
    (mu4e-get-mail-command "/usr/bin/mbsync -a")

    (mu4e-drafts-folder "/drafts")
    (mu4e-sent-folder "/sent")
    (mu4e-trash-folder "/trash")

    (message-send-mail-function 'message-send-mail-with-sendmail)
    (sendmail-program "/usr/bin/msmtp")
    (message-sendmail-extra-arguments '("--read-envelope-from"))
    (message-sendmail-f-is-evil 't)

    (mu4e-completing-read-function 'ivy-completing-read)
    (mu4e-confirm-quit nil)
    (message-kill-buffer-on-exit t)

    (mu4e-html2text-command "/usr/bin/w3m -T text/html")
    (mu4e-attachment-dir "~/")

    (mu4e-compose-signature
     '(user-full-name))

    :hook
    (message-send-hook .
                       (lambda ()
                         (unless (yes-or-no-p "Sure you want to send this?")
                           (signal 'quit nil))))

    :bind
    (("H-x m" . mu4e)
     ("C-x m" . mu4e-compose-new)))
#+end_src

** eww

=eww=, the Emacs Web Wowser, is a simple text-based web browser built
into Emacs. I use it somewhat frequently. So far the only
customization done here is making sure eww is uses olivetti-mode, for
better readability in web pages.

#+begin_src emacs-lisp :tangle init.el
  (use-package eww
    :bind
    ((:map eww-mode-map
          ("M-n" . scroll-up-line)
          ("M-p" . scroll-down-line))))
#+end_src

* Media management

Emacs can be used to manage all sorts of media playback
utilities. This is usually accomplished by means of packages that
provide frontends for certain local applications. For instance, we use
=mpdel= and =ivy-mpdel= to interface with =mpd= for music playback,
and =ytdl= and =ytel= to watch and download videos.

** Music

=mpdel= provides a range of functions for managing =mpd= playlists and
databases. =ivy-mpdel= adds Ivy completion to mpdel.

#+begin_src emacs-lisp :tangle init.el
  (use-package mpdel
    :straight ivy-mpdel
    :bind
    (:map music
          ("m" . ivy-mpdel-list)
          ("l" . mpdel-playlist-open)
          ("b" . mpdel-browser-open)))
#+end_src

** Videos

These are tools for downloading and streaming videos from the web.

*** ytdl

=youtube-dl=, as the name suggests, is a utility for downloading
videos from YouTube using the command line tool =youtube-dl=. Here we
configure the standard directories to be used by it.

#+begin_src emacs-lisp :tangle init.el
  (use-package ytdl
    :straight t
    :custom
    (ytdl-download-folder "~/vids")
    (ytdl-video-folder "~/vids")
    (ytdl-download-types '(("academic" "a" "~/vid/academic" nil)
                           ("documentaries" "d" "~/vid/documentaries" nil)
                           ("memes" "m" "~/vid/memes" nil)
                           ("lewd" "l" "~/vid/lewd" nil)
                           ("other" "o" "~/vid/" nil))))

  (use-package youtube-dl
    :straight t
    :custom
    (youtube-dl-directory "~/vid")
    :bind
    (:map youtube
          ("d" . youtube-dl)
          ("l" . youtube-dl-list)))
#+end_src

*** ytel

=ytel= is a package for searching for YouTube videos using the
=Invidious= API. It displays search results in a buffer similar to
elfeed.

#+begin_src emacs-lisp :tangle init.el
  (use-package ytel
    :straight t
    :functions ytel-get-current-video
    :custom
    (ytel-invidious-api-url "https://invidious.snopyta.org")
    :config
    (defun ytel-watch-mpv ()
      "Stream video at point in mpv."
      (interactive)
      (let* ((video (ytel-get-current-video))
             (id    (ytel-video-id video)))
        (start-process "ytel mpv" nil
                       "mpv"
                       (concat "https://www.youtube.com/watch?v=" id))
        "--ytdl-format=bestvideo[height<=?720]+bestaudio/best")
      (message "Starting stream..."))
    :bind
    (:map youtube
          ("y" . ytel)
     (:map ytel-mode-map
          ("RET" . ytel-watch-mpv))))
#+end_src

** Screencasts

Occasionally I record short screencasts of my Emacs usage. Sometimes
to show features to other users, and other times to demonstrate issues
I might be having. So here we install a few auxilliary packages, and
configure a simple function to help us in this task.

The packages installed are =gif-screencast=, which, using some
external tools, allows recording of the Emacs frame into gifs, and
=keycast=, which displays commands and keypresses in the modeline,
similar to the popular tool Screenkey. Both of these tools are used
for the screencasting.

The function defined below simply toggles the screencast on and off,
using both of the above packages. I've had issues with enabling and
disabling keycast-mode simply by calling it, so a slightly more
complex system, using =if= checks, has been implemented for that. The
function also leverages a toggle function built into gif-screencast,
which works similarly to the above.

#+begin_src emacs-lisp :tangle init.el
  (defun aabm/toggle-screencasting ()
    "Toggle screencasting using keycast-mode and gif-screencast on and off."
    (interactive)
    (if (eq keycast-mode t)
        (keycast-mode -1)
      (keycast-mode))
    (gif-screencast-start-or-stop))

  (use-package gif-screencast
    :straight t
    :commands gif-screencast-start-or-stop
    :bind
    (("C-c c r" . aabm/toggle-screencasting)))

  (use-package keycast
    :straight t)
#+end_src

* Theming, cosmetics and appearance

Finally, ricing. In this section we make all visual customisation,
install all cosmetic packages and color themes.

** All The Icons

#+begin_src emacs-lisp :tangle init.el
  (use-package all-the-icons
    :straight t
    :defer nil)
#+end_src

** Powerline

=Powerline= provides a neat custom modeline, which looks closer to the
default than, for instance, =doom-modeline= does. Here we set a custom
theme, based on the default. Only difference is that this theme does
not show =minor modes=, thus making =diminish= pointless.

#+begin_src emacs-lisp
  (use-package powerline
    :straight t
    :init

    (defun powerline-aabm-theme ()
      "Setup the custom mode-line."
      (interactive)
      (setq-default mode-line-format
                    '("%e"
                      (:eval
                       (let* ((active (powerline-selected-window-active))
                              (mode-line-buffer-id (if active 'mode-line-buffer-id 'mode-line-buffer-id-inactive))
                              (mode-line (if active 'mode-line 'mode-line-inactive))
                              (face0 (if active 'powerline-active0 'powerline-inactive0))
                              (face1 (if active 'powerline-active1 'powerline-inactive1))
                              (face2 (if active 'powerline-active2 'powerline-inactive2))
                              (separator-left (intern (format "powerline-%s-%s"
                                                              (powerline-current-separator)
                                                              (car powerline-default-separator-dir))))
                              (separator-right (intern (format "powerline-%s-%s"
                                                               (powerline-current-separator)
                                                               (cdr powerline-default-separator-dir))))
                              (lhs (list (powerline-raw "%*" face0 'l)
                                         (when powerline-display-buffer-size
                                           (powerline-buffer-size face0 'l))
                                         (when powerline-display-mule-info
                                           (powerline-raw mode-line-mule-info face0 'l))
                                         (powerline-buffer-id `(mode-line-buffer-id ,face0) 'l)
                                         (when (and (boundp 'which-func-mode) which-func-mode)
                                           (powerline-raw which-func-format face0 'l))
                                         (powerline-raw " " face0)
                                         (funcall separator-left face0 face1)
                                         (when (and (boundp 'erc-track-minor-mode) erc-track-minor-mode)
                                           (powerline-raw erc-modified-channels-object face1 'l))
                                         (powerline-major-mode face1 'l)
                                         (powerline-process face1)
                                         (powerline-narrow face1 'l)
                                         (powerline-raw " " face1)
                                         (funcall separator-left face1 face2)
                                         (powerline-vc face2 'r)
                                         (when (bound-and-true-p nyan-mode)
                                           (powerline-raw (list (nyan-create)) face2 'l))))
                              (rhs (list (powerline-raw global-mode-string face2 'r)
                                         (funcall separator-right face2 face1)
                                         (unless window-system
                                           (powerline-raw (char-to-string #xe0a1) face1 'l))
                                         (powerline-raw "%4l" face1 'l)
                                         (powerline-raw ":" face1 'l)
                                         (powerline-raw "%3c" face1 'r)
                                         (funcall separator-right face1 face0)
                                         (powerline-raw " " face0)
                                         (powerline-raw "%6p" face0 'r)
                                         (when powerline-display-hud
                                           (powerline-hud face0 face2))
                                         (powerline-fill face0 0)
                                         )))
                         (concat (powerline-render lhs)
                                 (powerline-fill face2 (powerline-width rhs))
                                 (powerline-render rhs)))))))

    (powerline-aabm-theme)

    :custom
    (powerline-default-separator "wave"))
#+end_src

** Color theme

Here we install a bunch of themes I like. These involve:
- Modus Themes by Protesilaos Stavrou
- The Majapahit theme
- The entire collection of themes from Doom Emacs, just for Gruvbox

The customizations applied to the doom-themes simply ensure some basic
features are enabled. We also ensure the Doom Gruvbox theme always
uses the Hard contrast variant, with a #1D2021 background instead of
the normal #282828.

#+begin_src emacs-lisp :tangle init.el
  (use-package modus-operandi-theme
    :straight t
    :custom
    (modus-operandi-theme-no-mixed-fonts nil)
    (modus-operandi-theme-proportional-fonts nil)
    (modus-operandi-theme-org-blocks 'greyscale))

  (use-package doom-themes
    :straight t
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    (doom-gruvbox-dark-variant "hard")
    (doom-themes-org-config))

  (load-theme 'doom-gruvbox t)
#+end_src

*** LEGACY Old color theme options

#+begin_src emacs-lisp
  (use-package modus-vivendi-theme
    :straight t
    :custom
    (modus-vivendi-theme-no-mixed-fonts nil)
    (modus-vivendi-theme-proportional-fonts nil)
    (modus-vivendi-theme-org-blocks 'greyscale))

  (load-theme 'modus-operandi t)
  (run-at-time "06:00" (* 60 60 24)
               (lambda ()
                 (enable-theme 'modus-operandi)))

  (load-theme 'doom-gruvbox t t)
  (run-at-time "18:00" (* 60 60 24)
               (lambda ()
                 (enable-theme 'doom-gruvbox)))
#+end_src

** Beacon

=beacon-mode= highlights the point everytime a significant motion
happens. It helps the user quickly locate the new position.

#+begin_src emacs-lisp :tangle init.el
  (use-package beacon
    :straight t
    :init
    (beacon-mode)
    :diminish beacon-mode)
#+end_src

** Mouse and cursor

#+begin_src emacs-lisp :tangle init.el
  (blink-cursor-mode -1)
  (tooltip-mode -1)
#+end_src

** Face customization

This is the face customization section. Here we change any faces that
do not look good by default. So far, the only faces included here
relate to fonts.

#+begin_src emacs-lisp :tangle init.el
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(Info-quoted ((t (:inherit fixed-pitch :foreground "#feacd0"))))
   '(fixed-pitch ((t (:family "Iosevka"))))
   '(fixed-pitch-serif ((t (:family "Go Mono"))))
   '(variable-pitch ((t (:height 150 :family "Cantarell")))))
#+end_src

** Frame options

Now we set the options to be used by default by the Emacs frame. These
include fonts, frame name (to be used by the window manager's
titlebar), frame size and transparency.

#+begin_src emacs-lisp :tangle init.el
  (set-frame-font "Iosevka 12" nil t)
  (setq frame-title-format "%b")

  (add-to-list 'default-frame-alist '(font . "Iosevka 12"))
  (add-to-list 'default-frame-alist '(width  . 100))
  (add-to-list 'default-frame-alist '(height . 30))
  (add-to-list 'default-frame-alist '(alpha 93 90))
  (set-frame-parameter (selected-frame) 'alpha '(93 90))
#+end_src
   
** LEGACY Dashboard

Dashboard is quite a nice package. It provides a startup screen with
customizable logo, clickable button and a general view of
things. However, I do not see it as being particularly useful. So it
is gone.

#+begin_src emacs-lisp
  (use-package dashboard
    :straight t
    :defer nil
    :config
    (dashboard-setup-startup-hook)
    :custom
    (dashboard-set-heading-icons t)
    (dashboard-set-file-icons t)
    (dashboard-items
          '((bookmarks . 5)
            (recents . 5)
            (agenda . 10)))
    (dashboard-banner-logo-title "Welcome to GNU Emacs!")
    (dashboard-startup-banner 'official)
    (dashboard-center-content t)
    (dashboard-show-shortcuts t)
    (dashboard-set-init-info t)
    (dashboard-set-footer t)
    (dashboard-footer-messages 
          '("We conjure the spirits of the computer with our spells..."
            "Happy hacking!"
            "The One True Editor, Emacs."
            "Vi Vi Vi, the editor of the beast."
            "Violence begins with Vi."
            "There is no system but GNU, and Linux is one of its kernels."

            "The proof of the pudding is in the eating."
            "In the beginning was the deed."
            "Vanitas! Vanitatum vanitas!"
            "Workers of the world, unite!"
            "A spectre is haunting Europe..."))
    (dashboard-set-navigator t)
    (dashboard-navigator-buttons
          `(;; line1
            ((,nil
              "Config"
              "Open config file for easy editing"
              (lambda (&rest _) (find-file "~/.emacs.d/emacs.org"))
              'default)
           (nil
            "Magit"
            "Open this config's local git repository"
            (lambda (&rest _) (magit "~/.emacs.d"))
            'default)
             (nil
              "Gitlab"
              "Open this config's Gitea page in your web browser"
              (lambda (&rest _) (browse-url "https://gitlab.com/aabm/emacs"))
              'default)
             )
            ;; line 2
            ((,nil
              "Email"
              "Read email with mu4e"
              (lambda (&rest _) (mu4e))
              'default)
             (nil
              "Elfeed"
              "Read RSS/Atom feeds with Elfeed"
              (lambda (&rest _) (elfeed))
              'default)
             (nil
              "Dired"
              "Manage files with dired"
              (lambda (&rest _) (dired "~/"))
              'default)))))

  ;; Load dashboard only if Emacs does not get a file as an argument
  (if (< (length command-line-args) 2)
    (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*"))))
#+end_src

** LEGACY Doom Modeline

:LEGACY:
Section dropped. Doom Modeline slightly impacts load time, and doesn't
really look all that much better than the standard. I actually dislike
how tall it is. I guess it has some fancy icons, but that's it. Not
really worth the tradeoff.
:END:

#+begin_src emacs-lisp
  (use-package doom-modeline
    :straight t
    :defer nil
    :custom
    (doom-modeline-height 25)
    (doom-modeline-bar-width 5)
    (doom-modeline-icon (display-graphic-p))
    (doom-modeline-major-mode-icon t)
    (doom-modeline-major-mode-color-icon t)
    (doom-modeline-buffer-state-icon t)
    (doom-modeline-buffer-modification-icon t)
    (doom-modeline-minor-modes nil)
    (doom-modeline-enable-word-count t)
    (doom-modeline-buffer-encoding t)
    (doom-modeline-persp-name t)
    :config
    (doom-modeline-mode))
#+end_src

* Start server

It is preferable to use Emacs as daemon in the background. Here we
start the Emacs server. We also add a little hook for displaying
startup time and garbage collection information.

#+begin_src emacs-lisp :tangle init.el
  (server-start)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs ready in %s with %d garbage collections."
                       (format "%.2f seconds"
                               (float-time
                                (time-subtract after-init-time before-init-time)))
                       gcs-done)))
#+end_src
